[Spring이란]
	
	-EJB로만 할 수 있었던 작업을 평범한 자바빈(POJO)를 사용해서 할 수 있도록 해준다.

	- 가벼운 의존성 주입(DI-Dependency Injection) 및 Aspect 기반 컨테이너 이자 프레임워크(AOP-Aspect Oriented Programming)

	- 복잡하고 규칙이 많은 EJB기반의 개발이 아닌  
	  POJO(Plain Old Java Object)기반의 개발로 클래스 사이의
	  상호 의존성이 적게 그리고 컨테이너를 통해 개체의 라이프 사이클을 관리하고
	  XML기반으로 컴포넌트를 개발할 수 있도록 지원해주는 Framework.

	- 엔터프라이즈 어플리케이션에서 필요로 하는 기능을 제공하는 프레임 워크

	- 스프링은 J2EE가 제공하는 다수의 기능을 지원하고 있기때문에
	  J2EE를 대체하는 프레임워크로 자리잡고 있음.

	- Plain Old Java Object인 Java Beans를 사용함에도 EJB와 같은 기능의 일을 처리 할 수 있다.
		
	- 웹 어플리케이션 뿐만 아니라 모든 Java Application 개발에 활용할 수 있다.
		struts(스트러츠)-웹어플리케이션 전용
	- 단순성,테스트 용이성,느슨한 결합성(DI의 기능)을 보장 받을 수 있다.
	

[Spring의 주요 특징]	

	1. 스프링은 POJO (Plain Old Java Object) 방식의 프레임워크로서, 일반적인 J2EE 프레임워크에 비해 특정 라이브러리를 사용할 필요가 없어서 
	  개발이 쉬우며, 기존 라이브러리의 지원이 용이.

	2. 스프링은 관점지향프로그래밍, AOP(Aspect Oriented Programming)를 지원. 트랜잭션, 로깅, 보안 등 여러 모듈, 여러 계층에서 적용되는데, 
	   이런 코드들을 실제 비지니스 로직과 분리할 수 있도록 도와준다. 한때, AOP가 OOP(Object Oriented Programming)를 대체하는 기술로 생각되기도 
	   했지만, 실제로 AOP는 OOP를 더욱 OOP스럽게 보완해 주는 기술이다.

	3. 스프링은 의존성 주입, DI (Dependency Injection)를 지원. 이는 객체간의 의존관계를 관리하는 기술로. 어떤 객체가 필요로 하는 객체를 
	   자기 자신이 직접 생성하는것이 아니라(new를 하지 않음), 외부에 있는 다른곳에서 자신이 필요로 하는 객체를 주입받는것을 말한다.

	4. 스프링은 제어 반전, IoC (Inversion of Controller)를 지원. 컨트롤의 제어권이 개발자가 아니라 프레임워크에 있음을 의미.
	   즉, 객체의 생성부터 모든 생명주기의 관리까지 객체의 제어권이 바뀐것을 의미한다.


[Spring의 구조]

+------------------------+  +-------------------------------+  +----------------------------+ +----------------------+
|    Spring AOP          |  |    Spring ORM                 |  |    Spring Web              | | Spring Web MVC       |
|                        |  |   Hibernate 지원 (쿼리문 자동)	    |  |  WebApplicationContext     | | Web MVC 프레임워크              |
| Source-level           |  |   iBatis 지원              		    |  |  Multipart resolver        | | JSP/Velocity         |
|   Metadata             |  |   JDO지원             			        |  |   Web utilities            | | PDF/Excel지원        		 |
| AOP infrastructure     |  +-------------------------------+  +----------------------------+ |                      |
|                        |  +-------------------------------+  +----------------------------+ |                      |
|                        |  |      Spring DAO               |  |    Spring Context          | |                      |
|                        |  |    Transation infrastructure  |  |   Application context      | |                      |
|                        |  |    JDBC지원               			    |  |	UI 지원/Validation		| |                      |
|                        |  |    DAO지원                			    |  |    EJB지원 Mail지원 			| |                      |
+------------------------+  +-------------------------------+  +----------------------------+ +----------------------+
+---------------------------------------------------------------------------------------------------------------------+
|                            Spring Core                                                                              |
|                        다양한 utilities 지원                                                                        |
|                        Bean container                                                                               |
+---------------------------------------------------------------------------------------------------------------------+

 Spring Core: DI라는 Dependency Injection기능 제공.BeanFactory를 기반으로 
                  Bean클래스들을 제어 할 수 있는 기능 제공
 
 Spring AOP: AOP(Aspect Oriented Programming)지원

 Sping ORM :ORM(Object Relational Mapping)기능을 제공하는 모듈.

 Spring DAO: DAO(Data Access Object )기능을 제공하느 모듈.
                  JDBC에 의한 데이타베이스 액세스를 지원
             즉 Persitence계층(데이타베이스)을 액세스 하여 사용할 수 있게 해주는 모듈

 Spring Web : 웹 어플리케이션 개발에 필요한  
		   Web Application Context 와 Multipart Request등의 기능을 지원

 Spring Context : 
 Core에서 지원하는 기능외에 추가적인 기능들과 좀 더 쉬운 개발이 가능하도록  지원.
                   유저 인터페이스 및 타당성검증이라는 애플리케이션 기반 성능,JNDI, 및 EJB의 지원 
		   메일 송수신기능을 제공

 Spring Web MVC: 웹 어플리케이션의 MVC 프레임워크 기능을 제공.JSP나 템플릿 엔진으로 유명한 Velocity지원 외에도
                 웹에서 PDF,Excel을 취급하기 위한 기능도 제공



[Spring Web MVC]

	- 스프링 프레임워크에 내장되어 있는 웹 프레임 워크
	- MVC패턴에 기반하기때문에 상호 의존도가 낮고 유연한 웹 기반의 
	   어플리케이션을 작성하기 쉽다.
	- 다양한 컨트롤러 제공
	  :두개의 Action계열(Action인터페이스/ActionSupport클래스)로 선택의 폭이 
	   한정되어 있는 스트러츠나 
	   웹워크등의 MVC프레임워크와 스프링이 구별되는 점임.
	- 낮은 결합도(AOP),의존성 주입(DI),확장성이라는 강력함때문에 대규모 사이트나 
	  유지보수가 많은 사이트에 주로 적용 됨.
	- 요청을 처리하기 위해 컨트롤러를 선택하는 방법과 결과를 보여주기 위해
          뷰를 선택하는 방식간에 
	  낮은 결합도를 유지하고 있다는 점이 무엇보다 중요함.

	 
	 Spring MVC의 라이프 사이클]
		중요!!!!!!!!외우기@@@
		root-context.xml에서 bean tag --bean 설정파일 controller의 연결에 역할
		
		DispatcherServlet => 프론트 서블릿 사용자에게 요청을 맨 처음으로  받음
		프레임 워크가 생성자 new해준다.	
	
	요청--->DispatcherServlet 1.
		 |   ▲	▲   ▲	▲
		 |   |	|   |	+--------------------------->2.HandlerMapping
	     |   |  |   |
		 |   |	|   +------------------------------->3.Controller    <-------->비즈니스 모델  --- Controller, 비즈니스모델을 프로그래밍해야한다.
		 |   |	|				           |											 	그 외는 프레임 워크에서 제공
		 |   |  +-------------4.ModelAndView---------------+ ModelAndView전달
		 |   |	 
		 |   +--------------------------------------->5.ViewResolver (어떤 view인지 해석)
         |
         +------------------------------------------->6.View-------->응답



		 1. 사용자의 모든 요청을 DispatcherServlet(Front Controller의 역할 즉 관문)이 받는다.
			- org.springframework.web.servlet.DispatcherServlet패키지

		 2. DispatcherServlet은 요청을 어느 컨트롤러에게 전달할지를 
		        HandlerMapping을 이용해 결정한다.
			- org.springframework.web.servlet.handler 패키지
			- HandlerMapping클래스는 
			서블릿명-servlet.xml에 등록된  요청과 컨트롤클래스 매핑정보를 읽어 
			  DispatcherServlet에게 전달
			- 1) BeanNameUrlHandlerMapping(기본 핸들러 매핑클래스임)
			  2) SimpleUrlHandlerMapping(쓸려면 bean설정파일에 등록해야함, 대신 등록하면 기본 핸들러는 사용불가.) --인자 생성자와 비슷한 느낌
			  		--비메이븐 에서는 그렇지만 메이븐은 상관 없다. <annotation-driven />로 annotation찾을 수 있기 때문
			  3) DefaultAnnotationHandlerMapping(기본 핸들러 매핑클래스임)

		 3. DispatcherServlet은 요청을 전달할 컨트롤을 결정한 후 해당 
		    Controller에게 요청을 넘긴다.(3.x에서는 어노테이션을 사용할것을 권장.
			4.x에서는 아래 컨트롤러들이 대부분 사라짐)
			- org.springframework.web.servlet.mvc
			- 1) Controller(interface)
			  2) AbstractController
			  3) AbstractCommandController(x-사라짐)
			  4) SimpleFormController(x-사라짐)
			  5) MultiActionController(x-사라짐)
		 
		 4. Controller는 별도로 작성한 비즈니스 모델에서 필요한 로직을 호출한 후 그 결과를 받아서 
		    결과 데이타와 어떤 View를 보여줄지를 ModelAndView개체에 저장한 후,  DispatcherServlet에 전달한다.
			

         5. DispatcherServlet은 View에 대한 정보를 담고 있는 
		    ViewResolver를 참조해서 Model를 뿌려줄 View정보를 얻는다.
		    
		    ViewResolver가 servlet-context.xml에서 
		    <beans:property name="prefix" value="/WEB-INF/views/" />참고해서 변환해줌
		    
			- org.springframework.web.servlet.view
			- ViewResolver은 가상의 경로를 실제 경로로 매핑해서
			  DispatcherServlet에게 전달한다.
			- 1) InternalResourceViewResolver(기본 ViewResolver)
		  	  2) ResourceBundleViewResolver
	          3) PropertiesMethodNameResolver
			  4) BeanNameViewResolver(다운로드시)


		 6. 요청한 사용자에게 View를 전달한다. 
			- org.springframework.web.servlet.view

			- 1) InternalResourceView(기본 View로 Jsp로 View를 보여줌)
			  2) JstlView
			  3) VelocityView
			  4) AbstractView등(다운로드를 처리할 클래스에서 extends해서 사용시)



	


	DispatcherServlet]

		- 스프링 MVC의 핵심으로서 프론트 컨트롤러의 역할을 함.
		- web.xml에 설정한 서블릿명과 같게 서블릿명-servlet.xml이라는(빈 설정 파일-WEB-INF에서 찾는다.-web.xml에서 쓰여있다.) 
		  파일을 이용해서 자바빈을 메모리에 로드.디폴트 위치는 WEB-INF밑에 위치
		

			

		[서블릿명-servlet.xml 이름변경]

		- DispatchServlet의 부모클래스인 FrameworkServlet의 
		  setContextConfigLocation(String contextConfigLocation)  
		  메서드를 web.xml환경설정
		  파일에서 속성으로 호출하여 디폴트 설정파일인 
		  서블릿명-servlet.xml의 파일명과 위치를  변경할 수 있다.
		  
		setter 인젝션은 
		반드시 파라미터 명을 contextConfigLocation로 해야 한다.

		  예]
		        springboard-servlet.xml 를 springboard-mymvc.xml로 변경

			<servlet>
				<servlet-name>springboard</servlet-name>
				<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
				<init-param>
					<param-name>contextConfigLocation</param-name>
					<param-value>/WEB-INF/config/myspringboard-mymvc.xml</param-value>	
				</init-param>
				<load-on-startup>1</load-on-startup>
				
			 </servlet>
			 <servlet-mapping>
				<servlet-name>springboard</servlet-name>
				<url-pattern>*.do</url-pattern>
			 </servlet-mapping>


		-  DispatchServlet을 여러개 등록할 수 있다. 각각의 DispatcherServlet은 서로 다른 WebApplicationContext를 생성하는데
		   각각의 WebApplicationContext에서 생성된 자바빈은 서로 공유가 안된다.!!!
		   즉 DispatcherServlet이 인스턴스화될때 생성되는 WebApplicationContext 간에 공통으로 사용하는 자바빈을
		   ContextLoaderListener를 통해 등록 할수 있다.
		   
		   ContextLoaderListener는 역시 WebApplicationContext를 생성하는 데 
		   이 WebApplicationContext가 바로
		   루트 컨텍스트로 ,DispatcherServlet에 의해 생성된 WebApplicationContext가 자식 컨텍스트가 된다.
		   따라서 ContextLoaderListener에 의해 생성된 자바빈은 모든 DispatcherServlet에서 공유할 수 있다.

		   단, 컨텍스트 초기화 파라미터로 공통빈을 등록하는 설정파일을 설정하지 않은 경우
		   디폴트 설정 파일은 WEB-INF/applicationContext.xml이 된다.

		   단, <context-param>
				<param-name>contextConfigLocation</param-name>
				<param-value>
					/WEB-INF/congif/공통빈설정파일.xml
				</param-value>
			</context-param>
			
			로 설정시에는 applicationContext.xml이 필요 없다.!!! 
			web-inf아래 있어야 한다.
			하지만 web.xml에서 
				<context-param>
					<param-name>contextConfigLocation</param-name>
					<param-value>/WEB-INF/spring/root-context.xml</param-value>
				</context-param>
			로 경로를 바꿀 수 있다.
		

                   예]

			<listener>
				<listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>  
			</listener>
			<context-param>
				<param-name>contextConfigLocation</param-name>
				<param-value>
					/WEB-INF/myservice-service.xml					
					/WEB-INF/mymodel-dao.xml
				</param-value>
			</context-param>

			
		   ※스프링 프레임워크에서는 BeanFactory가 자바빈의 라이프사이클을 관리하고 클래스간 계층도는 
		     BeanFactory > ApplicationContext > WebApplicationContext 이다.
		     즉 웹 어플리케이션에서는 ContextLoaderListener 나 DispatcherServlet이 인스턴스화 될때 
		     WebApplicationContext이 생성되어 자바빈의 라이프 사이클을 관리한다.

       	     ※[ContextLoaderListener와 DispatcherServlet비교]

                -------------------------------------------------------------+-------------------------------------------------------------------
                ContextLoaderListener                                 |    DispatcherServlet
                -------------------------------------------------------------+--------------------------------------------------------------------
등록 태그     <listener>                                                  |    <servlet>
                -------------------------------------------------------------+------------------------------------------------------------------
디폴트           WEB-INF/applicationContext.xml           |   WEB-INF/서블릿명-servlet.xml
설정파일
----------------------------------------------------------------------------+-----------------------------------------------------------------
설정 이름
및 위치변경       컨텍스트 초기화 파라미터                   |   서블릿 초기화 파라미터
가능 
----------------------------------------------------------------------------+------------------------------------------------------------------
설정파일           각 DispatcherServlet에 의해 생성된
주요 용도        독립된 각각의 컨텍스트에서 공통으로    |    사용자 요청을 처리할 자바빈 등록
                       사용할 자바빈 등록
------------------------------------------------------------------------------------------------------------------------------------------------
각각의 Dispatcher서블릿에서 등록한 자바빈은 서로 공유가 안됨.
단, ContextLoaderListener 의 빈 설정파일에 등록한 자바빈은 모든 DispatcherServlet에서 공유 가능


@@@
servlet-context.xml에서 
<context:component-scan base-package="com.kosmo.springapp" />
을 이용해서 context가 찾을 페키지 경로 ... 



		   컨텍스트 초기화 파라미터를 이용하지 않고 공통빈 등록하기 예]

		   1] 웹 어플리케이션이 실행될때 가장 먼저 실행되는 Listener 클래스를 web.xml에 등록

			 <listener>
				<listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>  
			</listener>
  

		   2] WEB-INF/밑에 applicationContext.xml파일을 생성하여 각 DispatcherServlet이 공유하는 클래스를 등록한다.


			-applicationContext.xml

				<?xml version="1.0" encoding="UTF-8"?>
				<beans xmlns="http://www.springframework.org/schema/beans"
					xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
					xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">


					<!--  DataSource using JNDI -->
					<bean id="dataSource" class="org.springframework.jndi.JndiObjectFactoryBean">
						<property name="jndiName" value="jdbc/MySpring"/>
						<property name="resourceRef">
							<value>true</value>
						</property>
					</bean>
					<!--  JdbcTemplate -->
					<bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
						<property name="dataSource" ref="dataSource"/>
					</bean>

					<!-- DAO Class -->

					<bean id="boardDAO" class="spring.board.model.BoardDAOImpl">		
						<property name="jdbcTemplate" >
							<ref bean="jdbcTemplate"/>
						</property>
					</bean>

				</beans>

			-springboard-mymvc.xml

				<?xml version="1.0" encoding="UTF-8"?>
				<beans xmlns="http://www.springframework.org/schema/beans"
					xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
					xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
					
					<!--  DataSource using JNDI -->
					<!-- <bean id="dataSource" class="org.springframework.jndi.JndiObjectFactoryBean">
						<property name="jndiName" value="jdbc/MySpring"/>
						<property name="resourceRef">
							<value>true</value>
						</property>
					</bean>
					-->
					<!--  JdbcTemplate -->
					<!-- 
					<bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
						<property name="dataSource" ref="dataSource"/>
					</bean>
					-->
					<!-- Controller Class -->
					<bean name="/boardList.do" class="spring.board.controller.BoardListController">	
						<property name="boardDAO" ref="boardDAO"></property>	
					</bean>
					<bean name="/boardDetail.do" class="spring.board.controller.BoardDetailController">
						<property name="boardDAO" ref="boardDAO"></property>	
					</bean>
					<bean class="spring.board.controller.BoardInsertFormController">
						<property name="boardDAO" ref="boardDAO"></property>	
									
					</bean>
					<bean class="spring.board.controller.BoardUpdateController">
						<property name="boardDAO" ref="boardDAO"></property>	
									
					</bean>
					<bean class="spring.board.controller.BoardDeleteController">
						<property name="boardDAO" ref="boardDAO"></property>	
									
					</bean>
					<!-- DAO Class -->
					<!--
					<bean id="boardDAO" class="spring.board.model.BoardDAOImpl">		
						<property name="jdbcTemplate" >
							<ref bean="jdbcTemplate"/>
						</property>
					</bean>
					-->

				</beans>

	HandlerMapping]
		-기본 핸들러매핑인  BeanNameUrlHandlerMapping(비 메이븐에서 사용) 및 
		DefaultAnnotationHandlerMapping을 명시하지 않으면
		프레임워크에서 자동으로 생성해 주지만
		만약 두 개의 핸들러 매핑을 사용시 어느 하나만 명시하면
		더이상 나머지 기본 핸들러 매핑을 제공해 주지 않는다.
		※만약 기본 핸들러 매핑이 아닌 다른 핸들러 매핑을 사용시에는
		  더 이상 기본 핸들러 매핑을 제공해주지 않음으로 반드시
		  기본 핸들러 매핑도 BEAN으로 등록(명시)해야 한다.

		- 요청을 컨틀롤러에 매핑시키는 클래스로 클래스에 따라서
                  다양한 방법으로 매핑 할 수 있다
		
		- 주요 핸들러 매핑 클래스
		
			BeanNameUrlHandlerMapping : 컨트롤러의 빈 이름(name속성)에 근거해서 컨트롤러를 URL에 매핑한다(디폴트 핸들러 매핑이다)
						    (org.springframework.web.servlet.handler)
			SimpleUrlHandlerMapping   :  
			프로퍼티 컬렉션을 이용해 한 섹션에서 요청과 컨트롤러를 매핑한다.
			즉 한곳에서 요청과 컨트롤러를 관리하기 
			                    위한 매핑
			   매핑시에는 컨트롤러 클래스의 id(id속성)를 이용해서 
			   컨트롤러를 URL에 매핑
						    (org.springframework.web.servlet.handler)
			DefaultAnnotationHandlerMapping : 
			Annotation을 이용해서 요청을 컨트롤 클래스와 매핑 한다
			                                  (@Controller ,@RequestMapping()등을 이용해 요청을 컨트롤러와 매핑함 이때 <bean>
							  생성시 name속성은 생략하고 class속성만 지정하면 됨-역시 디폴트 핸들러 매핑)
			                                  (org.springframework.web.servlet.mvc.annotation패키지)

		

			*디폴트 핸들러 매핑 클래스는 우리가 별도로 생성하지 않아도 
			스프링 프레임워크에서 내부적으로 생성하여 제공한다.
			*우리가 디폴트 핸들러 매핑을 사용하지않고 다른 핸들러 매핑을 사용하기 위해 
			 개체를 생성하는 경우(환경설정 파일에서)
			 디폴트 핸들러 매핑은 더 이상 제공되지 않는다 
			 따라서 함께 사용하려면 명시적으로 생성해줘야 한다.

			* 여러 핸들러 매핑을 사용하는 경우 각 핸들러 매핑에 property의 name속성에 order를 이용하여 우선순위를 정할 수 있다

			※No adapter for handler [컨트롤러@주소]: Does your handler implement a supported interface like Controller?
			위와 같은 에러 발생시 해결방법] 
			설정파일에 
			<mvc:annotation-driven/> 를 추가하거나
			
			<bean class="org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter"/>
	  		를 빈으로 등록
			예]

				<?xml version="1.0" encoding="UTF-8"?>
				<beans xmlns="http://www.springframework.org/schema/beans"
					xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
					xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
					<!--  DataSource using JNDI -->
					<!-- <bean id="dataSource" class="org.springframework.jndi.JndiObjectFactoryBean">
						<property name="jndiName" value="jdbc/MySpring"/>
						<property name="resourceRef">
							<value>true</value>
						</property>
					</bean>
					-->
					<!--  JdbcTemplate -->
					<!-- 
					<bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
						<property name="dataSource" ref="dataSource"/>
					</bean>
					-->
					
					
					
					<bean class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping">
						<property name="alwaysUseFullPath" value="true"></property>
						<!-- 우선 순위-->
						<property name="order" value="1"></property>
						<property name="mappings">
							<props>
								<prop key="/boardList.do">boardListController</prop><!--boardDetailController는 컨트롤러의 id값 
								                                                        /boardList.do는 요청-->
								<!-- <prop key="/boardDetail.do">boardDetailController</prop> -->
							</props>
							
						</property>
					</bean>
					<!-- BeanNameUrlHandlerMapping을 사용하기 위해 명시-->
					<bean class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping">
						<property name="order" value="3"></property>
					</bean>
					<!-- DefaultAnnotationHandlerMapping을 사용하기 위해 명시 즉 개체 생성
					     다른 핸들러 매핑(SimpleUrlHandlerMapping) 사용시 더 이상 제공되지 않음으로 직접 생성 해야 함-->
					<bean class="org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping">
						<property name="order" value="2"></property>
					</bean>
					
					<!-- Controller Class -->
					<!--  
					<bean name="/boardList.do" class="spring.board.controller.BoardListController">	
						<property name="boardDAO" ref="boardDAO"></property>	
					</bean>
					-->
					<bean id="boardListController" class="spring.board.controller.BoardListController">	
						<property name="boardDAO" ref="boardDAO"></property>	
					</bean>
					<!-- BeanNameUrlHandlerMapping-->
					<bean name="/boardDetail.do" class="spring.board.controller.BoardDetailController">
						<property name="boardDAO" ref="boardDAO"></property>	
					</bean>
					<!--  
					<bean id="boardDetailController" class="spring.board.controller.BoardDetailController">
						<property name="boardDAO" ref="boardDAO"></property>	
					</bean>
					
					-->
					<!--  DefaultAnnotationHandlerMapping -->
					<bean class="spring.board.controller.BoardInsertFormController">
						<property name="boardDAO" ref="boardDAO"></property>	
									
					</bean>
					<bean class="spring.board.controller.BoardUpdateController">
						<property name="boardDAO" ref="boardDAO"></property>	
									
					</bean>
					<bean class="spring.board.controller.BoardDeleteController">
						<property name="boardDAO" ref="boardDAO"></property>	
									
					</bean>
					

				</beans>



	ViewResolver]

		-  ViewResolver는 
		   ModelAndView클래스가 전달한 논리적인 View의 정보를 실제 물리적인 View의 
                  정보로 변환해서 DispatcherServlet에게 전송한다.

		- org.springframework.web.servlet.view 패키지		
		
		- InternalResourceViewResolver : 디폴트 ViewResolver로 Jsp페이지를 뷰로 선택한다.

		- prefix(접두사)와 suffix(접미사)속성을 이용하여 논리적인 이름으로 매핑
		
			예]

				- XML설정파일 예

				<!-- ViewResolver -->
				 <bean id="viewResolver" 
				 
				 class="org.springframework.web.servlet.view.InternalResourceViewResolver">
					
					<property name="prefix">
						<value>Board/</value>
					</property>
					<property name="suffix">
						<value>.jsp</value>
					</property>
				</bean>

				- 컨트롤러 예

				public ModelAndView handleRequest(HttpServletRequest arg0,
						HttpServletResponse arg1) throws Exception {
					
					
					List<BoardDTO> list = boardDAO.list();
					
					ModelAndView mav= new ModelAndView();
					mav.setViewName("list");//mav.setViewName("Board/list.jsp");  논리적인 이름으로 설정
					mav.addObject("boardList",list);
					return mav;
				}

				//수정이나 삭제후 리스트로 이동시에는 아래와 같이 직접 요청
				


				return new ModelAndView("redirect:/boardList.do"); 혹은 
				return new ModelAndView(new RedirectView("/boardList.do"));

				혹은
				//ModelAndVie mav=new ModelAndVie();
				//RedirectView view=new RedirectView("/boardList.do",true);		
				//mav.setView(view);
				//return mav;

				-상기는 요청을 공유하지 않음 즉 request영역을 공유하지 않음으로 request영역에 
				 저장된 값을 가져오지 못함

				 단,
				 //mav.setViewName("/boardList.do");은 Request영역 공유

 


[컨트롤러 계층 구조]
			
			1. 페이지 이동용 컨트롤러
				org.springframework.web.servlet.mvc.ParameterizableViewController
				<bean name="요청명" class="org.springframework.web.servlet.mvc.ParameterizableViewController">
					<!--이동하고자하는 페이지 설정-->
					<property name="viewName" value="JSP페이지 경로"/>
				</bean>

				예]

				
				<bean name="/index.do" class="org.springframework.web.servlet.mvc.ParameterizableViewController">									
						<property name="viewName" value="index.jsp"/>
				</bean>
			
			2. SimpleFormController 
				:HTML폼 전송에 유리한 컨트롤러. 
				  하나의 컨트롤러로 입력 폼과 처리를 담당. 또한 사용자 입력 값들을
				 커맨드 클래스(DTO게열)를 이용해서 쉽게 얻을 수 있다.

			3. MultiActionController

				:요청을 메서드에 매핑시켜 하나의 컨트롤러로 여러 요청을 처리할 수 있는 컨트롤러.가장 많이 사용
			-org.springframework.web.servlet.mvc패키지에 있음.
		
			Controller  +-------->AbstractController---------------+---------->MultiActionController
		                    |                                          |
                                    +-------->ParameterizableViewController    +---------->BaseCommandController-----+------->AbstractFormController----------+-------->SimpleFormController
				    |                                                                                |                                        |
				    +-------->UrlFilenameViewController                                              +------->AbstractCommandController       +-------->AbstractWizardFormController
			


            ※ .do요청과  매핑된 컨트롤러 클래스는 bean설정 파일에 하나만 등록 가능
	             여러개 동시 등록시 "There is already handler of type 컨트롤러클래스 mapped" 
	             에러 발생	         
	             단,  .do 요청과 매핑을 하지 않은 기타 클래스는 여러개 등록 가능 


[Dependency Injection]
	
	DI란?]
		- IOC(Inversion Of Control:역제어)의 한 형태
		- 의존성 주입 또는 종속개체 주입이라고 한다.
		- 의존성이란 개체와 개체사이에 존재하는 관계를 의미
		- 하나의 개체 안에서 다른 개체를 new연산자를 이용해서 생성시 
		  두 개체간에 결합도가 높아지고 
		  독립성이 떨어지게 된다.
		- 개체 스스로 new를 통해 필요한 개체를 생성하지 않고 
                  설정파일(xml)에서 주입을 받아 낮은  결합도를 유지 하는게 목적

	종속 개체 주입 방식]

		*spring-framework-버전\docs\spring-framework-reference\pdf에 있는 spring-framework-reference.pdf파일 참조

		- Constructor Injection
			
			:생성자의 인자를 통해서 개체를 주입 받는 방식
			
			package simple;

			public class SimpleMovieLister {
			
				private MovieFinder movieFinder;

				public SimpleMovieLister(MovieFinder movieFinder) {
					this.movieFinder = movieFinder;
				}
			
			}
			

			<beans>
				
				<bean name="simpleMovieLister" class="simple.SimpleMovieLister">
					<constructor-arg>
						<bean class="simple.MovieFinder"/>
					</constructor-arg>
				</bean>


			</beans>
			

			- 여러 개체 주입
			
			package x.y;
			public class Foo {

				public Foo(Bar bar, Baz baz) {
					// ...
				}
			}


			<beans>
				<bean name="foo" class="x.y.Foo">
					<constructor-arg>
						<bean class="x.y.Bar"/>
					</constructor-arg>
					<constructor-arg>
						<bean class="x.y.Baz"/>
					</constructor-arg>
				</bean>
			</beans>


			- 개체가 아닌 value주입(type과 index속성 및 value속성 이용)	
		
			package examples;
				public class ExampleBean {
				
				private int years;
				
				private String ultimateAnswer;

				public ExampleBean(int years, String ultimateAnswer,) {
					this.years = years;
					this.ultimateAnswer = ultimateAnswer;
				}
			}
			
			-type속성 이용

			<bean id="exampleBean" class="examples.ExampleBean">
				<constructor-arg type="int" value="7500000"/>
				<constructor-arg type="java.lang.String" value="42"/>
			</bean>

			-index속성 이용
			<bean id="exampleBean" class="examples.ExampleBean">
				<constructor-arg index="0" value="7500000"/>
				<constructor-arg index="1" value="42"/>
			</bean>


		- Setter Injection

			-Setter게열 메서드에 값을 전달할때는 <property name="속성명" value="값"/> 
			-Setter게열 메서드에 개체를 전달할때는 <property name="속성명" ref="참조이름"/> 
			그리고 참조이름의 <bean id="참조이름" class="패키지를 포함한 클래스명"/>을 생성한다

			
	



[Aspect Oriented Programming]

	- 관점 지향 프로그래밍 방식
	- 공통 관점(cross-cutting concern) 즉 보안,트랜잭션,예외처리등 
	  다른 클래스나 모듈에서 공통으로 필요한 기능을 분리하여
	  필요한 모듈에 제공해 줌으로써 핵심관점(core concern)에만 
	  집중 할 수 있도록 하는 프로그래밍 방식

	- Spring의 AOP 프레임워크에서 이런 기능을 제공 해줌
	- DI는 개체간의 결합도를 낮게 만드는 것이라면 AOP는 
	  DI의 확장된 개념으로 공통적인 관점을 갖고 있는 
	  개체들과의 결합도를
	  낮게 만드는 것이다.
	
	- AOP의 장점은 코드의 간결함과 유지보수의 편의성이다. 

	- oop나 기존 프로그래밍에서는 상속이나 메서드등으로 공통 부분등을 처리 했으나 
	  공통 부분이 수정이 되었을 경우 해당 공통부분을
	  호출하는 클래스들도 다시 수정하고 컴파일 해야하는 단점이 있다 
	  AOP는 공통 관심사항을
	  Spring의 AOP프레임 워크가 
	  공통사항(공통관점)을 분리해 호출하고 DI패턴처럼 필요한 클래스나 모듈에 주입하게 된다. 

	


	AOP관련 용어]

		Join Point: 메서드의 실행시점.혹은 필드값 변경등 , 
		                어느 위치를 기준으로 공통 모듈을 삽입하느냐.삽입지점
		Point Cut : 하나의 시작점 혹은 여러 시작점이 모여 Point Cut이 된다.
		                즉 하나의 Joint Point나 여러개의 Joint Point를 묶어서 Point Cut이라 함
		Advice:실제 코딩의 단위로 Point Cut이 모여서 Advice가 된다. 중요!!!!
		          즉 중복되는 공통 관심사항을 따로 코드로 만들어 놓은 것. Advice == 공통 관점(cross-cutting concern)
		Advisor: 여러 Advice나 Point Cut이 모여 
		             Advisor가 된다.
		Weaving:Advice를 핵심 로직코드에 적용하는 것을 
		             위빙이라고 함 즉 공통 코드를 핵심로직코드에 삽입하느것
		Wiring: xml에 bean등록하고(객체생성됨) 주입하는거
		
		Aspect:여러객체에 공통으로 적용되는 공통관심사항 
		         트랜잭션이나 보안,로깅등이 Aspect의 좋은 예


		 - Advice의 종류

		   Befor Advice:대상 객체의 메서드 호출전에 공통기능을 실행하는  Advice
		   After Advice:대상 객체의 메서드를 실행하는 도중에 
		    			예외가 발생했는지의 여부와 상관없이 메서드 실행 후 공통 기능을 실행하는 Advice
		   After Returning Advice:대상 객체의 메서드가 예외 없이 실행된후 실행되는 Advice
		   After Throwing Advice:대상 객체의 메서드를 실행하는 도중, 예외가 발새한 경우에 공통기능 실행하는 Advice
		   Around Advice: 대상 객체의 메서드 실행전/후, 또는
                                         예외발생 시점에 공통기능을 실행하는 Advice

		   * 이들 중 범용적으로 사용되는 것은 Around Advice임. 
		   즉 대상 객체의 메서드를 실행하기 전/후에 원하는 기능을 삽입 할 수 있기때문



		A클래스
		+--------------------------+
		| public void Bussiness1(){ |
		| 공통 기능 코드           |<------------------------------+
		|                          |                    |
		|  A핵심로직               |                               |
		|                          |                    +-----------------+               +-----------------------+
		| 공통 기능 코드           |                               | Spring          |               |                       |
		| }                        |				    |                 |               |                       |
		+--------------------------+                    | AOP 프레임 워크          |<------------->| 공통 관심 사항(모듈)        |
                                                        |                 |               |                       |
                                                        +-----------------+               +-----------------------+
		B클래스                                                       					|
		+--------------------------+                    |
		| public void Bussiness2(){ |                   |       
		| 공통 기능 코드           |<------------------------------+
		|                          |
		| B핵심로직                |
		|                          |
		| 공통 기능 코드           |
		| }                        |
		+--------------------------+

	- Spring의 AOP프레임 워크가 공통사항(공통관점)을 분리해 호출하고 
	   DI패턴처럼 필요한 클래스나 모듈에 주입하게 된다.
	  이때 주입의 대상이 되는 클래스를 Target클래스라 한다.

	 - 또한 공통관심사항을 핵심사항에 주입하는 작업을 Weaving이라 한다. 
	   위빙은 Complie시,혹은 Class로딩시 그리고 runtime시 할 수 있다.

	 -AOP구현 방법

		1)XML스키마 기반의 POJO클래스를 이용한 AOP구현


		2)@Aspect어노테이션기반의 AOP구현

		
		*위의 어떤 방식을 사용하더라도 스프링은 자체적으로 프록시 기반의 AOP를 지원함.
		 즉 메서드 호출 Joinpoint만을 지원.

	

	 AOP 실습]

		[XML스키마 기반의 POJO클래스를 이용한 AOP구현]
		
			1) AOP기능을 사용하기 위한 모듈 추가
				
				spring 3.x에서]
				외부 의존 클래스 에서 아래jar파일 추가 복사

				spring-framework-3.0.2.RELEASE-dependencies\org.aspectj\com.springsource.org.aspectj.weaver\1.6.8.RELEASE\
				1.com.springsource.org.aspectj.weaver-1.6.8.RELEASE.jar복사
				spring-framework-3.0.2.RELEASE-dependencies\org.aopalliance\com.springsource.org.aopalliance\1.0.0\
				2.com.springsource.org.aopalliance-1.0.0.jar복사
				spring-framework-3.0.2.RELEASE-dependencies\net.sourceforge.cglib\com.springsource.net.sf.cglib\2.2.0\
				3.com.springsource.net.sf.cglib-2.2.0.jar복사

				dist/org.springframework.aop-3.1.0.RELEASE.jar추가

				
				Spring 4.x에서]

				libs/org.springframework.aop-4.3.2.RELEASE.jar추가 하고 
				외부 의존 라이브러리는 3.x와 동일
				단,AspectJ Weaver는 1.8.X이상으로 (WEAVER로 검색)

			2) 위빙을 하기위한 Target클래스 작성
			
				- SpringAOPTest.java

				package spring.aop;

				public class SpringAOPTest {

						private int start;
						private int end;
						
						public void setStart(int start) {
							this.start = start;
						}

						public void setEnd(int end) {
							this.end = end;
						}

						public void printSum(){
							long sum =0;
							for(long i=start; i < end;i++){
								
								sum+=i;
							}
							System.out.println("sum="+sum);
							
						}
				}

			3) Advice 클래스 만들기

				-MyAdvice.java

				package spring.aop;
				
				
				import org.aspectj.lang.ProceedingJoinPoint;
				public class MyAdvice{
					
					public Object trace(ProceedingJoinPoint joinPoint) throws Throwable {
						String methodName="";
						//1.메서드 이름 얻어 오기		
						methodName=joinPoint.getSignature().toShortString();
						System.out.println("메서드 명: "+methodName);
						//2.핵심 메서드 호출전에 실행할 공통 로직
						long startTime=System.currentTimeMillis();
						
						//3. Advice를 적용할 핵심 메서드 호출
						Object obj=joinPoint.proceed();
						
						
						//4.핵심 메서드 호출 후의 적용할 공통 로직
						long endTime = System.currentTimeMillis();
						
						System.out.println("핵심 메서드 실행 시간: "+(endTime-startTime)+"ms");
						
						
						return obj;
					}
					
					
					
				}

			4) 설정 파일에 <aop:config>를 이용해서 Aspect를 설정. 
			    즉 Aspect를 어떤 pointcut에 적용할지를 지정(applicationContext.xml)
				
				- applicationContext.xml  (src밑에 위치)

					<?xml version="1.0" encoding="UTF-8"?>
					<beans xmlns="http://www.springframework.org/schema/beans"
					xmlns:aop="http://www.springframework.org/schema/aop"<!--aop사용을 위한 네임 스페이스-->
					xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
					xsi:schemaLocation="http://www.springframework.org/schema/beans
					http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
					http://www.springframework.org/schema/aop<!--aop사용을 위한 네임 스페이스-->
					http://www.springframework.org/schema/aop/spring-aop-2.5.xsd"><!--aop사용을 위한 네임 스페이스-->
					
					<!-- Target class-->
					<bean id="targetBean" class="spring.aop.SpringAOPTest">
						<property name="start" value="1"/>
						<property name="end" value="100000000"></property>
					</bean>
					<!-- 공통 모듈 즉 Advice-->
					<bean id="myAdvice" class="spring.aop.MyAdvice"/>
					<!--Advice를 어떤 Pointcut에 적용할지 설정-->
					<aop:config>
						<aop:aspect id="myAspect" ref="myAdvice"> <!-- Advice지정-->
							<!-- pointcut을 spring.aop 패키지 및 하위 패지지의 
							모든 public메서드 그리고 인자가 0개인상인 메서드에 적용--->
							<!--execution명시자:Advice를 적용할 패키지,클래스 그리고 메서드를 표현할때 사용-->
							<!--형식:execution(접근지정자패턴 리턴타입패턴 패키지이름패턴/메서드이름패턴/(파라미터 패턴)) =>AspectJ표현식이라고 함
							<!--
							수식어 패턴:생략가능(public ,protected등)
							*:모든 값
							..:0개 이상이라는 의미
							public * spring.aop..*(..)=>접근지정자가 public이고 모든 리턴타입에 대해 spring.aop패키지 및 그 이하에 있는 모든 패키지의
							모든 메서드에 대해 그리고 인자가 0개이상인 모든 메서드를 의미함.
								
							-->
							<aop:pointcut expression="execution(public * spring.aop..*(..))" id="publicMethod"/>
							<!-- Advice의 trace메서드를 Around Advice로 지정-->
							<aop:around method="trace" pointcut-ref="publicMethod"/>
						</aop:aspect>

					</aop:config>

					</beans>

			5)메인 메서드를 가진 실행 클래스 작성 -getBean()메서드로 bean개체를 가져와서 사용
				
				-MyAopMain.java

				package spring.aop;

				
				import org.springframework.context.ApplicationContext;
				import org.springframework.context.support.ClassPathXmlApplicationContext;
				

				public class MyAopMain {


					public static void main(String[] args) {
						

						ApplicationContext context=new ClassPathXmlApplicationContext("applicatonContext.xml");
						SpringAOPTest saopt = (SpringAOPTest)context.getBean("targetBean");
						saopt.printSum();

					}

			}


		
		[@Aspect어노테이션기반의 AOP구현]
			
			- XML파일에 Advice및 Pointcut을 설정 하지 않아도 자동으로 
			   Advice를 적용 할 수 있다.
			- Spring 2부터 지원.

			- @Aspect어노테이션을 이용해서 Aspect클래스를 구현. 
			이때 Aspect클래스는 Advice 를 구현한 메서드
			  와 pointcut 을 포함 해야 함.
			- @Pointcut 어노테이션을 적용한 메서드는 리턴타입이 void여야 한다.

			- xml설정 파일에서 <aop:aspectj-autoproxy/>를 설정

			1)번과 2번) 그리고 5)번은 같다

			3) Advice 클래스 만들기

				- MyAdvice2.java

				
				package spring.aop;

				import org.aspectj.lang.ProceedingJoinPoint;
				import org.aspectj.lang.annotation.Around;
				import org.aspectj.lang.annotation.Aspect;
				import org.aspectj.lang.annotation.Pointcut;


				//Aspect클래스 구현(Advice를 구현한 클래스)
				@Aspect
				public class MyAdvice2{
					
					//Pointcut정의
					//spring.aop패키지 하위의 모든 메서드에 공통로직(Advice)를 주입하겠다
					@Pointcut("execution(public * spring.aop..*(..))")
					public void myTarget(){}
					
					
					@Around("myTarget()")//Around Advice구현
					public Object trace(ProceedingJoinPoint joinPoint) throws Throwable {
						String methodName="";
						//1.메서드 이름 얻어 오기		
						methodName=joinPoint.getSignature().toShortString();
						System.out.println("메서드 명: "+methodName);
						//2.핵심 메서드 호출전에 실행할 공통 로직
						long startTime=System.currentTimeMillis();
						
						//3. Advice를 적용할 핵심 메서드 호출
						Object obj=joinPoint.proceed();
						
						
						//4.핵심 메서드 호출 후의 적용할 공통 로직
						long endTime = System.currentTimeMillis();
						
						System.out.println("핵심 메서드 실행 시간: "+(endTime-startTime)+"ms");
						
						
						return obj;
					}
					
					
					
				}

			4)xml 설정파일

				-applicationContext.xml

					<?xml version="1.0" encoding="UTF-8"?>
					<beans xmlns="http://www.springframework.org/schema/beans"
					xmlns:aop="http://www.springframework.org/schema/aop"
					xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
					xsi:schemaLocation="http://www.springframework.org/schema/beans
					http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
					http://www.springframework.org/schema/aop
					http://www.springframework.org/schema/aop/spring-aop-2.5.xsd">
					
					<!-- 이 부분만 추가 됨. Aspect설정에 관한 사항 필요 없음-->
					<aop:aspectj-autoproxy/>
					<!-- 대상클래스 객체 생성-->
					<bean id="targetBean" class="spring.aop.SpringAOPTest">
						<property name="start" value="1"/>
						<property name="end" value="100000000"></property>
					</bean>
					<!-- Advice객체생성-->
					<bean id="myAdvice" class="spring.aop.MyAdvice2"/>
					



					</beans>

			※웹 어플리케이션 버전 AOP구현

				-설정파일에 AOP 를 테스트할 컨트롤러 선택후  주입
				예]
				<bean class="green.board.controller.FileUploadController">
					<property name="targetBean" ref="targetBean"/>
				</bean>

				-컨트롤러 에서 

				@Controller
				public class FileUploadController {
					
					
					private SpringAOPTest targetBean;
					
					public void setTargetBean(SpringAOPTest  targetBean) {
						this.targetBean = targetBean;
					}
					//파일 업로드 폼으로 이동
					@RequestMapping(value="/fileUpload/FileUpload.do",method=RequestMethod.GET)
					public String fileUploadForm(){
						//폼으로 이동시 주입 테스트-즉 웹 어플에서는 Main메서드가 없음으로
						targetBean.printSum();
						return "/fileUpload/uploadForm";
					}
					....생략
				}

		
[데이타베이스 연동]-DataBase

	- 아파치에서 제공하는 DBCP API사용을 위한 환경 설정(JNDI를 이용한 DBCP]

	1]Tomcat버전/conf/server.xml의 <GlobalNamingResources>태그 사이에 세팅

		<Resource auth="Container"
				driverClassName="oracle.jdbc.driver.OracleDriver" 
				maxActive="20" maxIdle="10" maxWait="-1"
				name="jdbc/myoracle" password="tiger" 
				type="javax.sql.DataSource"
				url="jdbc:oracle:thin:@127.0.0.1:1521:orcl" 
				username="scott"/>
			


				maxActive - The maximum number of connections that can be allocated from this pool at the same time. Default: 8 
				minIdle - The minimum number of connections that will sit idle in this pool at the same time. Default: 0 
				maxIdle - The maximum number of connections that can sit idle in this pool at the same time. Default: 8 
				maxWait - The maximum number of milliseconds that the pool will wait (when there are no available connections)
				for a connection to be returned before throwing an exception. Default: -1 (infinite) 


	2]Tomcat버전/conf/context.xml의 <Context reloadable="true"> 태그 사이에 아래부분 세팅
	  -어느 웹 어플리케이션이든지 위에서 등록한 이 리소스를 사용하게 할 수 있도록 
		<ResourceLink global="jdbc/myoracle"
				name="jdbc/myoracle"
				type="javax.sql.DataSource"/>



	3] 데이타베이스 연동 코딩 - 스프링 프레임워크에서는 DataSource를 의존성 주입(DI)즉 환경설정 파일에서 생성함

	-dbcpTest.jsp


	<%@ page language="java" contentType="text/html; charset=EUC-KR"
	    pageEncoding="EUC-KR"%>
	    
	 <%@ page import="javax.sql.DataSource" %>
	 <%@ page import="java.sql.Connection" %>
	 <%@ page import="java.sql.Statement" %>
	 <%@ page import="java.sql.ResultSet" %>
	  <%@ page import="javax.naming.InitialContext" %>
	<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
	<html>
	<head>
	<meta http-equiv="Content-Type" content="text/html; charset=EUC-KR">
	<title>DBCP 연결 테스트</title>
	</head>
	<body>
		<h2>DBCP를 이용한 데이타베이스 연결 테스트</h2>
		<%
			InitialContext ctx = new InitialContext();
			out.println("ctx="+ctx+"<br/>");
			DataSource ds =(DataSource)ctx.lookup("java:comp/env/jdbc/myspring");
			out.println("ds="+ds+"<br/>");
			if(ds !=null){
				
				
				Connection con = ds.getConnection();
				out.println("con="+con+"<br/>");
				
				Statement stmt = con.createStatement();
				ResultSet rs= stmt.executeQuery("SELECT * FROM emp");
				
				out.println(rs.getRow()+"<br/>");
				
				while(rs.next()){		
					
					out.println(rs.getString("EMPNO")+" "+rs.getString("ENAME")+rs.getDate("HIREDATE")+"<br/>");
					
				}
				
				if(rs!=null) rs.close();
				if(stmt!=null) stmt.close();
				if(con !=null) con.close();
			}
			else{
				out.println("이름으로 개체찾기 실패");
				
			}
		
		
		
		%>
	</body>
	</html>

[스프링 프로젝트 시작하기]

	-개발환경 설정
	
		개발도구-스프링 프레임워크가 내장된 이클립스버전 다운로드(SpringSource Tool Suit(STS))

		-방법1] 이클립스에 스프링이 내장되어 별도로 플러그인 할 필요 가 없고 스프링에 맞게 최적화 됨.(예:Spring Project)
     
			http://spring.io/tools/sts->DOWNLOAD STS

		-방법2]기존의 이클립스에 플러그인

			Help->eclipse MARKETPALCE->FIND부분에 STS
			
			

	가)비 메이븐 방식의 프로젝트
	
		
	
		1)Dynamic Web Project생성
		
		2)라이브러리 다운로드 및 등록

			[Spring 3.x를 위한 개발 준비사항]

			다운받는곳:http://docs.spring.io/downloads/nightly/release-download.php?project=SPR
			
			spring-framework-3.1.0.RELEASE-with-docs.zip	
			와
			spring-framework-3.0.2.RELEASE-dependencies.zip(스프링이 필요로하는 외부 라이브러리들 포함되어 있음)



			[Spring 4.x를 위한 개발 준비사항]

				다운받는곳:http://repo.spring.io/release/org/springframework/spring/

				spring-framework-4.x.x.RELEASE-dist다운
		
			-Spring 3.x버전 프로젝트 생성]
			
			1] spring-framework-3.1.0.RELEASE-with-docs.zip압축을 푼다

				dist/org.springframework.web-3.1.0.RELEASE.jar
				dist/org.springframework.web.servlet-3.1.0.RELEASE.jar   
				dist/org.springframework.core-3.1.0.RELEASE.jar
				dist/org.springframework.beans-3.1.0.RELEASE.jar
				dist/org.springframework.jdbc-3.1.0.RELEASE.jar
				dist/org.springframework.orm-3.1.0.RELEASE.jar
				dist/org.springframework.asm-3.1.1.RELEASE.jar            ?
				dist/org.springframework.context-3.1.1.RELEASE.jar
				dist/org.springframework.expression-3.1.1.RELEASE.jar
				dist/org.springframework.transaction-3.1.1.RELEASE.jar    
				dist/org.springframework.aop-3.1.0.RELEASE.jar1

				위의  11개의 파일을 WEB-INF/lib폴더에 복사

				그리고 spring-framework-3.0.2.RELEASE-dependencies.zip압축을 풀어

				org.apache.commons\com.springsource.org.apache.commons.logging\1.1.1\com.springsource.org.apache.commons.logging-1.1.1.jar역시
				 WEB-INF/lib폴더에 복사

			-Spring 4.x버전 프로젝트 생성]
			1-1]spring-framework-4.2.8.RELEASE-dist.zip압축을 푼다
				dist/org.springframework.web-4.2.8.RELEASE.jar 
				libs/org.springframework.webmvc-4.2.8.RELEASE.jar 
				libs/org.springframework.core-4.2.8.RELEASE.jar
				libs/org.springframework.beans-4.2.8.RELEASE.jar
				libs/org.springframework.jdbc-4.2.8.RELEASE.jar
				libs/org.springframework.orm-4.2.8.RELEASE.jar				       ?
				libs/org.springframework.context-4.2.8.RELEASE.jar
				libs/org.springframework.expression-4.2.8.RELEASE.jar
				libs/org.springframework.tx-4.2.8.RELEASE.jar     
				libs/org.springframework.aop-4.2.8.RELEASE.jar
			
				※https://mvnrepository.com에서 logging으로 검색후 Logging클릭후
				  commons-logging-1.버전.jar 다운로드 
				
				※3.x에서 4.x의 라이브러리 변환
				web.servlet이 webmvc로 
				transaction이 tx로
				asm는 core로 통합
				 
				 
				 ※주요 라이브러리 설명
				 core-DI기능을 포함한 스프링 프레임워크의 기반을 제공하는 가장 핵심적인 모듈.asm에 의존
				 beans-BeanFactory인터페이스를 통해 스프링 컨테이너 Bean들의 라이프 사이클 관리.
				       ApplicationContext는 BeanFactory상속.core에 의존
					  
				 expression-객체에 접근하고 조작하기위한 표현언어를 제공.EL의 확장
				 context-core와 beans의 확장으로 ApplicationContext를 지원.beans와expression에 의존
				 asm-core모듈이 의존하는 ROOT모듈로 클래스 바이트 코드 조작 및 분석 프레임워크인 ASM을 
				     재패키징한 모듈이다. 스프링 3.0부터 자바 5.0이상을 요구한다.고로 자바 1.4이하버전에서는
				     스프링 3.x버전을 사용불가
					 
				
				 
			2] web.xml에 스프링 프레임워크를 사용하기 위한 설정			

								
				  <servlet>
						<servlet-name>springtest</servlet-name>
						<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
						<load-on-startup>1</load-on-startup>
				  </servlet>
				  <servlet-mapping>
						<servlet-name>springtest</servlet-name>
						<url-pattern>*.do</url-pattern>
				  </servlet-mapping>
				  
				


			3] 컨트롤러 역할을 하는 클래스 작성

			   - MVC의 컨트롤러 역할을 하는 클래스
			   - org.springframework.web.servlet.mvc패키지에 있는 
			      스프링에서 제공하는 Controller인터페이스 구현하거나
			     혹은 AbstractController클래스를 extends 하면
			     스프링 프레임워크에서 컨트롤러의 역할을 하는 클래스 자격을 갖추게 됨.
			   - handleRequest메서드 오버라이딩
			     
			     이 메서드에서 하는 일은  
			     1)모델의 비즈니스 로직을 호출하고
			     2)그 결과를 request개체에 setAttribute로 저장하고
			     3)그 결과를 view를 통해서 전달
			     
				request.setAttribute("키값","Value값");
				return new ModelAndView("이동할 페이지.jsp");
				혹은	     
				ModelAndView mav = new ModelAndView();
				//View정보를 설정
				mav.setViewName("이동할 페이지명.jsp");
				//Model을 설정 즉 ModelAndView에 View정보와 Model정보를 담아 Dispatcher Servlet에게 전송한다.		
				mav.addObject("키값","Value값");  -->addObject메서드를 통해 Model을 request 영역에 저장한다.
				return mav;  -->Dispatcher Servlet으로 전달


				- SpringTestController.java
					package spring.test;

					import javax.servlet.http.HttpServletRequest;
					import javax.servlet.http.HttpServletResponse;

					import org.springframework.web.servlet.ModelAndView;
					import org.springframework.web.servlet.mvc.Controller;

					public class SpringTestController implements Controller {

						public ModelAndView handleRequest(HttpServletRequest req,
								HttpServletResponse arg1) throws Exception {
							req.setAttribute("greeting","스프링에 오신걸 환영합니다!!");
							return new ModelAndView("SpringResult.jsp");
						}

					}


				
			       -  SpringTestController2.java
			       
					package spring.test;

					import javax.servlet.http.HttpServletRequest;
					import javax.servlet.http.HttpServletResponse;

					import org.springframework.web.servlet.ModelAndView;
					import org.springframework.web.servlet.mvc.Controller;

					public class SpringTestController implements Controller {

						public ModelAndView handleRequest(HttpServletRequest req,
								HttpServletResponse arg1) throws Exception {
							ModelAndView mav = new ModelAndView();
							mav.addObject("greeting","스프링에 오신걸 환영합니다!!");
							mav.setViewName("SpringResult.jsp");
							return mav;
						}

					}

	
			4] xml설정파일 작성
			
			   - 요청과 컨트롤역할을 하는 클래스간의 매핑정보를 설정한  
			     서블릿명-servlet.xml 파일 생성
			     (other->Spring->Spring Bean Configuration File)
			   - 스프링으로부터 인터페이스를 제공받아서 
			      컨트롤러의 역할을 부여 받은 컨트롤러 클래스와 
			      스프링을 xml설정파일을 통해 연결 시켜줘야 함(와이어링이라고 함)

			   - 파일명은 web.xml에서 설정한 
			   서블릿이름-servlet.xml로 한다(예:springapp-servlet.xml)하고
			     저장 위치는 /WEB-INF/아래에 저장(web.xml과 같은 위치)
			     spring bean Configuration File로 생성해서 사용


			     예]
					<?xml version="1.0" encoding="UTF-8"?>
					<beans xmlns="http://www.springframework.org/schema/beans"
						xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
						xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
						
						<bean name="/springTest.do" class="spring.test.SpringTestController"/>

					</beans>
			5] Jsp 페이지 작성

				- SpringTest.jsp

					<%@ page language="java" contentType="text/html; charset=UTF-8"
					    pageEncoding="UTF-8"%>
					<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
					<html>
					<head>
					<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
					<title>Insert title here</title>
					</head>
					<body>
						<h2> 스프링 테스트</h2>
						<a href="springTest.do">스프링</a>
					</body>
					</html>

				- SpringResult.jsp

					<%@ page language="java" contentType="text/html; charset=EUC-KR"
					    pageEncoding="EUC-KR"%>
					<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
					<html>
					<head>
					<meta http-equiv="Content-Type" content="text/html; charset=EUC-KR">
					<title>Insert title here</title>
					</head>
					<body>
						<h2><%=request.getAttribute("greeting") %></h2>
						<h2>${greeting}</h2>
					</body>
					</html>

		3) 데이타베이스 연동 


			- JDBC API를 이용한 연동  테스트

				- DBCponnectTest.jsp

					<%@page import="java.sql.DriverManager"%>
					<%@page import="java.sql.Connection"%>
					<%@ page language="java" contentType="text/html; charset=UTF-8"
					    pageEncoding="UTF-8 "%>
					<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
					<html>
					<head>
					<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
					<title>Insert title here</title>
					</head>
					<body>
						<h2>데이타베이스 연결 테스트</h2>
						<%
							Class.forName("oracle.jdbc.OracleDriver");
							Connection con = DriverManager.getConnection("jdbc:oracle:thin:@127.0.0.1:1521:orcl","scott","tiger");
							
							if(con!=null) out.println("데이타베이스 연결 성공");
						
						
						%>
					</body>
					</html>

			- 커넥션 풀을 사용한 연동 테스트

				- 아파치에서 제공하는 DBCP API(커넥션 풀)사용을 위한 환경 설정

				1]Tomcat버전/conf/server.xml의 <GlobalNamingResources>태그 사이에 세팅

					<Resource auth="Container" driverClassName="oracle.jdbc.OracleDriver" maxActive="20" maxIdle="5" name="jdbc/MySpring" password="tiger" type="javax.sql.DataSource" url="jdbc:oracle:thin:@127.0.0.1:1521:orcl" username="scott"/>


							maxActive - The maximum number of connections that can be allocated from this pool at the same time. Default: 8 
							minIdle - The minimum number of connections that will sit idle in this pool at the same time. Default: 0 
							maxIdle - The maximum number of connections that can sit idle in this pool at the same time. Default: 8 
							maxWait - The maximum number of milliseconds that the pool will wait (when there are no available connections)
							for a connection to be returned before throwing an exception. Default: -1 (infinite) 


				2]Tomcat버전/conf/context.xml의 <Context reloadable="true"> 태그 사이에 아래부분 세팅

					 -어느 웹 어플리케이션이든지 위에서 등록한 이 리소스를 사용하게 할 수 있도록 
					<ResourceLink name="jdbc/MySpring"
					    global="jdbc/MySpring"
					    type="javax.sql.DataSource"/>



				3] 데이타베이스 연동 방법1 - 스프링의 JNDI이용


					- springboard-servlet.xml

					  <?xml version="1.0" encoding="UTF-8"?>
						<beans xmlns="http://www.springframework.org/schema/beans"
							xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
							xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
							
							
							
							<!--  DataSource using Spring JNDI -->
							<bean id="dataSource" class="org.springframework.jndi.JndiObjectFactoryBean">
								<property name="jndiName" value="jdbc/MySpring"/>
								<property name="resourceRef">
									<value>true</value>
								</property>
							</bean>
							<!--  JdbcTemplate -->
							<bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
								<property name="dataSource" ref="dataSource"/>
							</bean>
							<!--  DAO -->
							<bean id="springTestDAO" class="spring.test.model.SpringTestDAO">
								<property name="jdbcTemplate" ref="jdbcTemplate"/>
							</bean>
							<!--  Controller -->
							<bean name="/springTest.do" class="spring.test.SpringTestController2"/>
							
							<bean name="/springJNDI.do" class="spring.test.SpringJndiController">
								<property name="springTestDAO" ref="springTestDAO"/>
							</bean>
							
						</beans>


					- SpringJndiController.java


						package spring.test;

						import java.util.List;

						import javax.servlet.http.HttpServletRequest;
						import javax.servlet.http.HttpServletResponse;

						import org.springframework.jdbc.core.JdbcTemplate;
						import org.springframework.web.servlet.ModelAndView;
						import org.springframework.web.servlet.mvc.Controller;

						import spring.test.model.SpringTestDAO;
						import spring.test.model.SpringTestDTO;

						public class SpringJndiController implements Controller {


							private SpringTestDAO springTestDAO;
							
							public void setSpringTestDAO(SpringTestDAO springTestDAO) {
								this.springTestDAO = springTestDAO;
							}

							public ModelAndView handleRequest(HttpServletRequest arg0,
									HttpServletResponse arg1) throws Exception {
								
								List<SpringTestDTO> list = springTestDAO.list();
								
								ModelAndView mav= new ModelAndView();
								mav.setViewName("DBConnectJNDI.jsp");
								mav.addObject("tabList",list);
								return mav;
								
								
							}

						}
				


					- SpringTestDAO.java

						package spring.test.model;

						import java.sql.ResultSet;
						import java.sql.SQLException;
						import java.util.List;

						import org.springframework.jdbc.core.JdbcTemplate;
						import org.springframework.jdbc.core.RowMapper;

						public class SpringTestDAO {
							
							private JdbcTemplate jdbcTemplate;
							
							
							public void setJdbcTemplate(JdbcTemplate jdbcTemplate) {
								this.jdbcTemplate = jdbcTemplate;
							}


							public List<SpringTestDTO> list(){
								
								
								//쿼리결과를 가져와서 DTO클래스와 매핑시켜주는 RowMapper인터페이스를 상속받은 
										//클래스를 내부 클래스로 작성 하거나 혹은 익명클래스로 작성하고
										//mapRow를 오버라이딩하여 내가 만든 DTO클래스와 쿼리결과를 매핑시켜주자
								RowMapper mapper = new RowMapper(){
									//오라클에서 가져온 쿼리 결과를(첫번째 인자에 담김) 레코드 개수만큼
									//mapRow가 호출되어 DTO클래스에 매핑 시켜줌
									//즉 개발자가 반복해서 호출하는것이 아니라 래코드 개수만큼 시스템에 의해 반복 
									//호출되어(CALLBACK) 컬렉션에 DTO클래스를 담아줌
									public Object mapRow(ResultSet arg0, int arg1) throws SQLException {
										SpringTestDTO dto = new SpringTestDTO();
										dto.setTname(arg0.getString(1));
										dto.setTabtype(arg0.getString(2));
										dto.setClusterid(arg0.getInt(3));				
										return dto;
									}
									
								};
								
								return jdbcTemplate.query("SELECT * FROM tab",mapper);
								
							}
						}

					- SpringTestDTO.java


						package spring.test.model;

						public class SpringTestDTO {

							private String tname;
							private String tabtype;
							private int clusterid;
							public String getTname() {
								return tname;
							}
							public void setTname(String tname) {
								this.tname = tname;
							}
							public String getTabtype() {
								return tabtype;
							}
							public void setTabtype(String tabtype) {
								this.tabtype = tabtype;
							}
							public int getClusterid() {
								return clusterid;
							}
							public void setClusterid(int clusterid) {
								this.clusterid = clusterid;
							}
						}

					- DBConnectJNDI.jsp

						WEB-INF/lib에 jstl.jar와 standard.jar 복사

						<%@ page language="java" contentType="text/html; charset=EUC-KR"
						    pageEncoding="EUC-KR"%>
						 <%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
						<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
						<html>
						<head>
						<meta http-equiv="Content-Type" content="text/html; charset=EUC-KR">
						<title>Insert title here</title>
						</head>
						<body>
							<h2>JNDI를 이용한 데이타베이스 연결</h2>
							<c:forEach items="${tabList}" var="list">
							
								${list.tname} ${list.tabtype} ${list.clusterid} <br/>
								
							
							</c:forEach>
						</body>
						</html>

				3] 데이타베이스 연동 방법2 - DriverManagerDataSource이용(스프링의 JDBC)

					- springboard-servlet.xml 에서 DataSource부분만 수정 아래와 같이 수정

					  <?xml version="1.0" encoding="UTF-8"?>
						<beans xmlns="http://www.springframework.org/schema/beans"
							xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
							xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
							
							
							
							<!--  DataSource using Spring JDBC -->
							<bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">
								<property name="driverClassName" value="oracle.jdbc.OracleDriver"/>
								<property name="url" value="jdbc:oracle:thin:@127.0.0.1:1521:orcl"/>
								<property name="username" value="scott"/>
								<property name="password" value="tiger"/>
								
							</bean>


							<!--  JdbcTemplate -->
							<bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
								<property name="dataSource" ref="dataSource"/>
							</bean>
							<!--  DAO -->
							<bean id="springTestDAO" class="spring.test.model.SpringTestDAO">
								<property name="jdbcTemplate" ref="jdbcTemplate"/>
							</bean>
							<!--  Controller -->
							<bean name="/springTest.do" class="spring.test.SpringTestController2"/>
							
							<bean name="/springJNDI.do" class="spring.test.SpringJndiController">
								<property name="springTestDAO" ref="springTestDAO"/>
							</bean>
							
						</beans>
	나) 메이븐 방식의 프로젝트

		Step1] File->New->Other->Spring으로 검색후 Spring Legacy Project선택
		Step2] Project Name에 프로젝트명 입력후 Spring MVC Project선택후 Next
		Step3] 최소 3레벨이 적용된 TOP-LEVEL 패키지명 입력(예:com.mycompany.myapp) 그리고 finish

		※프로젝트 생성시 스프링 버전은 3.1.x버전이다


		최신버전으로 스프링 프로젝트 바꾸기]

		1) Project Facet 변경

			-프로젝트명 우클릭-> Properties선택->Project Facet선택.

			Dynamic Web Module -> 3.1

			Java -> 1.8로 변경
			
			-프로젝트명 우클릭-> Properties선택->Java Complie선택->1.8로 선택

		2)pom.xml 변경
			
			-http://mavenrepository.com에서 최신 버전 확인후 적용

			<properties>
				<java-version>1.6</java-version>
				<org.springframework-version>3.1.1.RELEASE</org.springframework-version>
				<org.aspectj-version>1.6.10</org.aspectj-version>
				<org.slf4j-version>1.6.6</org.slf4j-version>
			</properties>

			를 아래 처럼 변경후 파일 저장시 스프링 모듈 3.1.x가 4.2.x대 모듈로 변경이 된다
			<properties>
				<java-version>1.8</java-version>
				<org.springframework-version>4.2.8.RELEASE</org.springframework-version>
				<org.aspectj-version>1.6.10</org.aspectj-version>
				<org.slf4j-version>1.6.6</org.slf4j-version>
			</properties>

			

			※톰캣 8.0대(서블릿 api 3.1) 설치 디렉토리의 lib폴더의 servlet-api.jar를
			  JAVA_HOME의 jre\lib\ext에 복사한 경우 아래는 주석처리해도 됨.
			  서블릿 api 2.5는 톰캣 6.0의 스펙이다
			<!-- Servlet -->
			<dependency>
				<groupId>javax.servlet</groupId>
				<artifactId>servlet-api</artifactId>
				<version>2.5</version>
				<scope>provided</scope>
			</dependency>를 아래처럼 변경(서블릿 버전을 2.5에서 3.1(톰캣 8.0대)로 변경)
			<dependency>
			<groupId>javax.servlet.jsp</groupId>
			<artifactId>jsp-api</artifactId>
			<version>2.1</version>
			<scope>provided</scope>
		  </dependency>

			<dependency>
				<groupId>javax.servlet</groupId>
				<artifactId>javax.servlet-api</artifactId>
				<version>3.1.0</version>
				<scope>provided</scope>
			</dependency>
			
		3)web.xml의 루트 엘리먼트 변경 즉 웹모듈 2.5에서 3.1로 변경--
		<web-app version="2.5" xmlns="http://java.sun.com/xml/ns/javaee"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd">
		에서

		<web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
		xmlns="http://xmlns.jcp.org/xml/ns/javaee" 
		xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" id="WebApp_ID" 
		version="3.1
		로 변경
		※라이브러리 다운 문제로 인한 프로젝트 오류
		 1.로컬 저장소 삭제:
           Windows->Preferences->Maven->User Settings에서 로컬 저장소 확인
		   예]C:\Users\1702-00\.m2\repository
		   즉 repository디렉토리안의 모든 폴더 삭제
		 2.프로젝트 우클릭->Run As -> Maven Clean -> Maven Install
		 

[Annotation]
		

	- Annotation은 클래스 앞이나 메서드 앞에 @지시자를 이용해서  해당 클래스나 메서드의 역할을 컴파일러에게    
          알려주는 주석문의 일종이다

	- 스프링 3.x 버전에서는  Controller와 AbstractController를 제외한 대부분의 컨트롤러가 
	  Deprecated되었다. 즉 사용을 권장하지 않는다. 대신에 Annotation을 사용한다.
			
	- 대부분 org.springframework.web.bind.annotation패키지에 있음.

	- 주요 Annotation 

		 @Controller: 클래스앞에 붙인다. 
				   컨트롤러로서의 클래스라고 Annotation하기위한 것
				   org.springframework.stereotype패키지에 존재

		 @RequestMapping: 메서드 앞에 붙인다. 
		 요청을 메서드와 매핑 시키기위한 Annotation
				
				 
				 ※ @RequestMapping어노테이션이 적용된 메서드의  파라미터 타입

					- 서블릿 API :HttpServletRequest/HttpServletResponse/HttpSession
					- 요청 컨텐츠에 직접 접근시:InputStream,Reader
					- 응답 컨텐츠 생성시:OutputStream,Writer
					-  Http요청 파라미터 매핑시 :@RequestParam
					- 뷰에 전달할 모델 데이타 설정시 : Map,Model,ModelMap
					-  @ModelAttribute어노테이션을 이용한 커맨드 개체 : 
					   DTO계열의 클래스
					-  Http요청 파라미터를 커맨드 개체에 저장한 결과,
					   커맨드 객체를 위한 파라미터 바로 다음에 위치:Erros,BindingResult
				  


		 @ModelAttribute : 메서드의 매개변수 자료형 앞에 붙인다.
				   입력폼이나 수정 폼의 파라미터를 
				   HttpRequestServelet개체로 직접 받지 않고
				   커맨트 개체(DTO계열의 개체)에 받을때 사용하는 
				   Annotation(파라미터 많은 경우 유리)
				   예] updateBoard(@ModelAttribute BoardDTO dto)

		 @RequestParam : 메서드의 매개변수 자료형 앞에 붙인다.
				 매개 변수가 한 두개 정도인 경우  HttpRequestServelet개체로 직접 받지 않고
				 해당 자료형으로 받고잘 할때 사용하는 Annotation.
				 형변활 필요 없이 해당 자료형으로 받으면 된다.
				 예] deleteBoard(@RequestParam int idx)
				 주의사항: @RquestParam은 반드시 파라미터로 넘길때만 사용가능
					      안그러면 404뜬다(콘솔에 에러는 표시안됨)
					      파라미터로 넘김지않은경우 쓰면 안됨(예:최초목록페이지)
					      즉 최초 목록 페이지는 현재 페이지를 나나태는
					      파라미터를 전달 안함으로...단,required속성을 false로 설정시는 상관없음
		  또한 파라미터는 기본이 String타입(getParameter()반환타입)임으로
		  파라미터를 int타입으로 받는 경우 ,값을 입력 안하거나
		  파라미터명이 없다면 NumberFormatException무조건 발생
		  왜냐하면 프레임워크 내부적으로
		  String을 Integer.parseInt(파라미터값)함으로
	 예]
	 public String execute(@RequestParam(value="nowPage", required=false) String nowPage,
	//required 속성은 기본이 ture 이며, 필수가 아닌 파리미터는 false로 지정                         
	@RequestParam(value="number", defaultValue="0") int number)
	//number가 null일때  defaultValue에 설정한  값으로 설정됨





		@Required

			- 컨트롤러 클래스에서 setter계열 메서드에
			  지정시 설정파일에서 <property>를 지정안하면 예외 발생
			  또한 request로 값을 받을때 값이 넘어오지 않으면 예외발생
			-RequiredAnnotationBeanPostProcessor클래스를
			  빈 객체로 등록후 사용
			 <bean 
		class="org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProc
		essor"/>
		 혹은 <context:annotaion-config/>만 등록하여 주어도 자동으로 
		 @Required를 사용할 수 있다


		@Autowired
		-의존관계 자동설정(type기반)
		-생성자,필드,메서드에 적용가능
		-setxxx()의 형식이 아니어도 적용가능
		-타입을 이용해 자동적으로 프로퍼티 값을 
		 설정하므로 해당 타입의 빈 객체가 존재하지 않거나 또는
		 빈 객체가 두 개 이상 존재할 경우 예외를 발생시키게 된다.
		단,@Autowired 어노테이션에 required 속성의 값을 false로 지정해 주면
		해당 타입의 빈 객체가 존재하지 않더라도 예외를 발생하지 않는다.
		-사용시 설정파일에 AutowiredAnnotationBeanPostProcessor클래스를
		 빈 객체로 등록후 사용
		 혹은 <context:annotaion-config/>만 등록하여 주어도 자동으로 
		 @Autowired를 사용할 수 있다

		-@Autowired적용시에는 컨트롤러 클래스에 setter계열메서드 생력하고
		 설정파일에서 <property>생략
		주의:type으로 와이어링 하기때문에 속성에 동일한 자료형이 존재하는 경우
		       설정파일에서 생성된 bean객체의 같은 주소가 와이어링된다
		       즉 다른 주소를 갖는 객체가 아니다

		@Resource어노테이션
			-어플리케이션에서 필요로하는 자원을 자동 연결할때 사용
			-name속성에 자동으로 연결할 빈 객체의 이름을 지정
			 만약 빈 객체가 존재하지 않으면,스프링은 컨테이너를 초기화하는 과정에서 예외 
			발생

			-@Autowired는 같은 기능을 함.차이점은 @Autowired는 by type으로 
			@Resource(name="id값")는 by name으로 연결




		@ResponseBody : 반환되는 문자열을 응답바디에 바로 출력해주는 어노테이션
					
		예]
		@ResponseBody
		public String execute(@RequestParam String text) throws Exception{
			String html="<html>";
				   html+="<body><h2>"+text+"</h2></body>";
				   html+="</html>";
			
			return html;
		}
		<!-- @ResponseBody (반환타입:String) 한글처리(deprecated 되었음-2014년 초) -->	
		<bean class="org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter">
		    <property name="messageConverters">
			<list>
			    <bean class="org.springframework.http.converter.StringHttpMessageConverter">
				<property name="supportedMediaTypes">
				    <list>
					<value>text/html;charset=utf-8</value>
				    </list>
				</property>
			    </bean>			
			</list>		
		    </property>
		</bean>
		
		※@ResponseBody사용시 한글깨짐 방지
		Step 1] @RequestMapping(value="요청명",,produces="text/html; charset=UTF-8")
		Step 2] 빈 설정 파일에 <mvc:annotation-driven/>태그 추가


		※<mvc:annotation-driven>은 어노테이션 방식의 @MVC를 사용시 필요한 몇가지 빈들을 자동으로 등록해 준다.
		자동으로 등록되는 빈에는 AnnotationMethodHandlerAdapter와 DefaultAnnotationHandlerMapping와 MessageConverter등이 있으며
		 @ResponseBody로 어노테이션이 되어 있다면 메소드에서 리턴되는 값은 View 를 통하지 않고 HTTP 응답바디 에 직접 출력 된다.
		 리턴되는 데이터 타입에 따라 MessageConverter 에서 변환이 됨.


	- Annotation을 이용한 입력 폼으로 이동 및 DB에 입력처리 하기]

		* 어노테이션을 이용하여  사용자의 요청을, 메서드 단위로 매핑.
		  (2.5버전때도 가능했으나 3.x버전부터는 적극 사용을 권장함)
		* 요청을 메서드에 매핑시 메서드의 인자는 임의로 가능하다. 즉 HttpServletRequest나 HttpServletResponse클래스 및 
		  어노테이션(@ModelAttribute나 @RequestParam등)을 이용해 파라미터값을 읽어 올 수 있다.

		1)서블릿명-servlet.xml 에서 <bean />에서 name을 포함하지 않고 class속성만 지정
		  즉 기본 핸들러 매핑 클래스인 BeanNameUrlHandlerMapping를 사용해서 매핑을 안함. Bean객체 생성만으로도
		  어노테이션을 이용해 매핑이 가능해졌다.

		2)컨트롤러 클래스 작성시

		  Controller계열의 인터페이스나 클래스를 구현혹은 상속받지 않고 클래스앞에
		  @Controller(org.springframework.stereotype패키지)라는 어노테이션을 추가한다 즉 
		   컴파일러에게 Controller역할을 하는 클래스라는 것을 알려주기 위함.

		3)컨트롤러 역할을 하는 클래스의 메서드 앞에 @RequestMapping("요청명") 혹은 
		@RequestMapping(value="요청명",method=RequestMethod.GET) 
		  어노테이션 추가(org.springframework.web.bind.annotation패키지)

		*method=RequestMethod.GET 나 method=RequestMethod.POST는 넘어오는 요청이 GET방식이나 POST방식인 경우에 각 요청방식에
		 맞는 요청을 처리하라는 의미.

		
		@SessionAttributes:스프링에서 세션처리시 사용하는 어노테이션

		예]
		@Controller
		@SessionAttributes("UserID")
		public class SpringSession{


			@RequestMapping("/Session.do")
			public String execute(Model model) throws Exception{

				model.addAttribute("UserID","아이디");//@SessionAttributes설정으로 세션영역에 저장됨
				model.addAttribute("UserPass","비번");//리퀘스트 영역에 저장됨
				
				return "/Session.jsp";
			}

		}

		※여러개의 키를 세션에 저장하고 싶다면 @SessionAttributes의 "키" 들을 { }로 묶어준다.

		  예] @SessionAttributes({"UserID","UserPass","Name"})


		@Repository/@Component/@Service/@Controller: 해당 클래스의 성격에 따라 적절한 어노테이션 선택
		※스프링은 클래스 패스에 위치한 클래스를 검색하여 특정한 어노테이션이 붙은
		클래스를 자동으로 빈으로 등록하는 기능 제공
		xml파일에 빈 정보를 추가하지 않고도 특정한 클래스들의 빈을 등록할 수있다.

		@Repository(DAO 및 DTO계열에 적용),@Component,@Controller,@Service(서비스를 구현한 Impl계열 클래스에 적용)이들 어노테이션을 클래스
		선언부분에 붙이고
		xml설정파일에 <context:component-scan base-package="팩키지명"/>태그를
		추가하면 스프링은 지정한 팩키지에서
		이 어노테이션이 적용된 클래스를 검색하여 자동으로 빈으로 등록한다.

		@Component("myClass")같이 어노테이션 속성에 빈의 ID을 명시해준다
		빈의 ID을 명시해주지 않을 경우 스프링은 클래스의 첫 글자를
		소문자로 바꾼 클래스의 이름을 빈 ID으로 등록한다


		예]

		package com.mydomain.myapp;
		import org.springframework.stereotype.Component;

		@Component("myClass")
		public class MyClass {


		}

		-설정 파일
		<beans...>

		<context:component-scan base-package="com.mydomain.myapp" />

		</beans>


		결론]
		<!-- 
		base-package속성:최상위 패키지 지정
		-bean을 프레임워크에 등록하지 않아도 최상위 프레임워크를 하위 프레임워크까지 스캔하면서
		 bean을 모두 생성한다
		 단,@Controller/@Component/@Repository/@Service를 클래스 앞에 붙여야 한다.
		 각각의 클래스 성격에 맞게 적당한 어노테이션을 붙이면 된다.
		
		@Controller:사용자 요청을 처리하는 컨트롤러 클래스
		@Component:자바빈 클래스
		@Repository:DTO계열 클래스등(데이타 저장소 역할을 하는 클래스)
		@Service:서비스 역할을 하는 클래스(Impl계열 클래스)
		
		이때 인젝션은 @Resource를 통한 인젝션이 주를 이룬다  
		 
		 -->


	 기타]
	 @RequestHeader:
	 public String execute(@RequestHeader("Accept-Language") String lang
					    ,@Requ estHeader("User-Agent") String agent){   }
	 @CookieValue:
	 public String execute( @CookieValue(value="userID", required=false) String userID){}



[iBATIS]

	

	- ORM(Object Relational Mapping) 프레임워크의 하나
	- 데이타베이스와 객체와의 관계를 매핑시켜 퍼시스턴트 로직 처리를 도와주는 프레임 워크
	- XML파일에 매핑 정보를 기술하여 데이타베이스의 테이블과 
	  자바개체를 매핑하여 데이타베이스에 생성,조회,수정,삭제(CRUD)
	  작업을 도와주는 역할

	- JDBC를 사용할때 보다 60% 정도의 코드만으로 프로그램 작성이 가능
	- 자바코드와 SQL문의 분리로 인해 프로그램 배포시에도 프로그램 변경시 컴파일 작업이 필요없이 XML파일의 변경 만으로
	  쉽게 수정 가능

	- Apache 재단(비영리기관)에서 Goolge로 프로젝트가 이전되면서 MyBatis로 명칭이 바뀜
	- 스프링4 에서 iBatis라이브러리가 빠짐 즉 org.springframework.orm.ibatis.SqlMapClientFactoryBean와
	  org.springframework.orm.ibatis.SqlMapClientTemplate클래스를 제외 시켰다.

		1) 환경 설정
					
			-http://attic.apache.org/projects/ibatis.html->Apache Archive클릭->http://archive.apache.org/dist/ibatis/->binaries클릭
			-> ibatis-2.3.4.726.zip 다운로드  

			-압축을 푼 후 WEB-INF/lib폴더에 
			 ibatis-2.3.4.726.jar 파일 복사

		2) 환경설정 파일 수정

			- ibatis-2.3.4.726\simple_example\com\mydomain\data폴더에 있는 SqlMapConfig.xml를 복사하여

			  Java Resources/src에 붙여 넣는다.(Resources.getResourceAsReader()메소드에서 파일명만 넣으면 됨.)

			  그리고 같은 DAO류의 패키지에  Account.xml을 참조하여 해당 프로젝트에 맞세 수정한다.


		 
			- SqlMapConfig.xml 수정

				<?xml version="1.0" encoding="UTF-8" ?>

				<!DOCTYPE sqlMapConfig      
				    PUBLIC "-//ibatis.apache.org//DTD SQL Map Config 2.0//EN"      
				    "http://ibatis.apache.org/dtd/sql-map-config-2.dtd">

				<sqlMapConfig>

				  <!-- Configure a built-in transaction manager.  If you're using an 
				       app server, you probably want to use its transaction manager 
				       and a managed datasource -->
				  <transactionManager type="JDBC" commitRequired="false">
				    <dataSource type="SIMPLE"> <!-- type에는 SIMPLE, DBCP,JNDI등이 있음 SIMPLE이 기본값 JNDI는 WAS서버의 server.xml에 등록한 이름으로 
								 DataSource개체를 찾아쓰는 방법임-->
				      <property name="JDBC.Driver" value="oracle.jdbc.driver.OracleDriver"/>  <!-- oracle.jdbc.driver.OracleDriver로 변경-->
				      <property name="JDBC.ConnectionURL" value="jdbc:oracle:thin@localhost:1521:orcl"/>  -->jdbc:oracle:thin@localhost:1521:orcl로 수정
				      <property name="JDBC.Username" value="scott"/>
				      <property name="JDBC.Password" value="tiger"/>
				    </dataSource>
				  </transactionManager>

				  <!-- List the SQL Map XML files. They can be loaded from the 
				       classpath, as they are here (com.domain.data...) -->
				  <sqlMap resource="spring/board/model/Board.xml"/>   -->spring/board/model/Board.xml로 수정(패키지를 /로 접근함)
				  <!-- List more here...
				  <sqlMap resource="com/mydomain/data/Order.xml"/>
				  <sqlMap resource="com/mydomain/data/Documents.xml"/>
				  -->

				</sqlMapConfig>

			- Account.xml를   Board.xml 수정  

		
				<?xml version="1.0" encoding="UTF-8" ?>

				<!DOCTYPE sqlMap      
				    PUBLIC "-//ibatis.apache.org//DTD SQL Map 2.0//EN"      
				    "http://ibatis.apache.org/dtd/sql-map-2.dtd">

				<sqlMap namespace="Board">

				  <!-- Use type aliases to avoid typing the full classname every time. -->
				  <typeAlias alias="BoardDTO" type="spring.board.model.BoardDTO"/>  <!--DTO계열 빈을 별칭 부여	,
												      SqlMapConfig.xml에 위치시키는게 더 유리함 다른 .xml파일에서도
												      사용 가능토록-->

  
				  <!-- Result maps describe the mapping between the columns returned
				       from a query, and the class properties.  A result map isn't
				       necessary if the columns (or aliases) match to the properties 
				       exactly. -->
				  
				    <--클래스의 속성과 컬럼명이 일치하다면 필요 없다.기술시에는  일치하는 경우 column속성 생략하고
					아래와 같이 기술 -->
				  <resultMap id="BoardDTOResult" class="BoardDTO">
				    <result property="idx" />
				    <result property="writer" />
				    <result property="title"/>
				    <result property="content" />
				    <result property="hitcount" />
				    <result property="postdate" />
				    <result property="password" />
				  </resultMap>

				  <!-- Select with no parameters using the result map for Account class. -->
				  <select id="selectAllBoard" resultMap="BoardDTOResult">
				    select * from boardspring3 order by idx desc
				  </select>
				  <insert id="insertMemo" parameterClass="Memo">   <!-- 클래스에는 위에서 부여한 별칭을 id는 임의로 .자바 코드에서는 각 쿼리문의 id값으로 접근함.
				  INSERT INTO struts_memo values(#writer#,#memo#,#email#)
				  </insert>
				  <delete id="deleteMemo" parameterClass="String">
				  
				  DELETE  FROM struts_memo WHERE writer=#writer#
				  </delete>
				  <select id="selectMemoById" parameterClass="String" resultClass="Memo">
				    SELECT * FROM struts_memo WHERE writer=#writer#
				 </select>
				 <update id="updateMemo" parameterClass="Memo">
				 
				UPDATE struts_memo SET email=#email#,memo=#memo# WHERE writer=#writer#
				 </update>
				</sqlMap>

	

		3) simple_example\com\mydomain\data에 있는 SimpleExample.java파일을 복사하여 DAO계열에 있는
		   패키지에 복사후 이름과 소스를 알맞게 수정한다

	
			- BoardManager.java

				package spring.board.model;
				import com.ibatis.sqlmap.client.SqlMapClient;
				import com.ibatis.sqlmap.client.SqlMapClientBuilder;
				import com.ibatis.common.resources.Resources;
				import java.io.Reader;
				import java.io.IOException;
				import java.util.List;
				import java.sql.SQLException;


				public class BoardManager {


					  private static SqlMapClient sqlMapper;


					  static {
					    try {
					      Reader reader = Resources.getResourceAsReader("SqlMapConfig.xml");
					      sqlMapper = SqlMapClientBuilder.buildSqlMapClient(reader);
					      reader.close(); 
					    } catch (IOException e) {
					      // Fail fast.
					      throw new RuntimeException("Something bad happened while building the SqlMapClient instance." + e, e);
					    }
					  }

					  public static List<BoardDTO> selectAllBoard() throws SQLException {
					    return sqlMapper.queryForList("selectAllBoard");
					  }
				 }

			

		 

		4) BoardDAOImpl.java에서 Dao계열 메서드 수정


					public List<BoardDTO> list()  {
						//iBatis로 수정후
						List<BoardDTO> list=null;
						try {
							list=BoardManager.selectAllBoard();
						} catch (SQLException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						return list;
						//iBatis로 수정전

						/*
						String sql="SELECT * FROM boardspring3 ORDER BY idx DESC";
						
						//쿼리결과를 가져와서 DTO클래스와 매핑시켜주는 RowMapper인터페이스를 상속받은 
						//클래스를 내부 클래스로 작성 하거나 혹은 익명클래스로 작성하고
						//mapRow를 오버라이딩하여 내가 만든 DTO클래스와 쿼리결과를 매핑시켜주자
						RowMapper mapper= new RowMapper(){
							//오라클에서 가져온 쿼리 결과를(첫번째 인자에 담김) 레코드 개수만큼
							//mapRow가 호출되어 DTO클래스에 매핑 시켜줌
							//즉 개발자가 반복해서 호출하는것이 아니라 래코드 개수만큼 시스템에 의해 반복 
							//호출되어(CALLBACK) 컬렉션에 DTO클래스를 담아줌
							public Object mapRow(ResultSet rs, int arg1) throws SQLException {
									BoardDTO dto = new BoardDTO();
									dto.setIdx(rs.getInt(1));
									dto.setWriter(rs.getString(2));
									dto.setTitle(rs.getString(3));
									dto.setContent(rs.getString(4));
									dto.setHitcount(rs.getInt(5));
									dto.setPostdate(rs.getDate(6));
									dto.setPassword(rs.getString(7));
								return dto;
							}
						
						};
								
						return jdbcTemplate.query(sql, mapper);
						
						*/
					}



	- JNDI를 이용한 DataSource 설정:톰캣의 server.xml에 등록한 JNDI명을 이용해서 DataSource가져오기
	
	
		:sqlMapConfig.xml에서 아래 부분만 수정

		<sqlMapConfig>
			  <transactionManager type="JDBC" commitRequired="false">
			    <!--  
			    <dataSource type="SIMPLE">
			      <property name="JDBC.Driver" value="oracle.jdbc.driver.OracleDriver"/>
			      <property name="JDBC.ConnectionURL" value="jdbc:oracle:thin:@localhost:1521:orcl"/>
			      <property name="JDBC.Username" value="scott"/>
			      <property name="JDBC.Password" value="tiger"/>
			    </dataSource>		  
			    -->

			  <dataSource type="JNDI">  <!--1] type을 JNDI로-->
				<!-- name에는 DataSourcc를  value속성에는 server.xml에 설정한 JNDI명을 Tomcat의 서브 컨텍스트인 java:/comp/env
				     와 연겷 값을 아래와 같이 설정-->
				<property name="DataSource" value="java:/comp/env/jdbc/MySpring"/>
			  </dataSource>

			  </transactionManager>

			 <sqlMap resource="spring/board/model/Board.xml"/>
		 

		</sqlMapConfig>

	- 외부 리소스를 사용한  DataSource 설정

		1)Other->General->File에서 확장자가 .properties파일 생성
			
			-dataSource.properties

			driver=oracle.jdbc.OracleDriver
			url=jdbc:oracle:thin:@localhost:1521:orcl
			user=scott
			pwd=tiger

		2)sqlMapConfig.xml 수정

			<sqlMapConfig>
			  <properties resource="spring/board/model/dataSource.properties"/><!--패키지를 포함함 경로-->
			  <transactionManager type="JDBC" commitRequired="false">
			   
			    <dataSource type="SIMPLE">
			      <property name="JDBC.Driver" value="${driver}"/>
			      <property name="JDBC.ConnectionURL" value="${url}"/>
			      <property name="JDBC.Username" value="${user}"/>
			      <property name="JDBC.Password" value="${pwd}"/>
			    </dataSource>	 

			  </transactionManager>

			 <sqlMap resource="spring/board/model/Board.xml"/>
		 

		</sqlMapConfig>


	- SqlMapClientTemplate 클래스

		-스프링에서 제공하는 클래스로 SqlMapClient를 사용할때 발생하는  
		SQLException을 처리하기 위한
		 코드(try~catch)의 중복을 없애기위해 Wrapping한 클래스
		-내부적으로 iBatis의 SqlMapClient를 사용한다.
		-스프링은 SqlMapClient를 스프링 설정파일에서 쉽게 설정할 수 있도록 돕는 
		  SqlMapClientFactoryBean클래스
		 를 제공함. 이를 통해 SqlMapClient를 스프링 빈으로 설정 할 수 있음.

		 예]
		<-- jndi를 이용한 DataSource-->
		<bean id="dataSource" class="org.springframework.jndi.JndiObjectFactoryBean">
			<property name="jndiName" value="jdbc/MySpring"/>
			<property name="resourceRef">
				<value>true</value>
			</property>
		</bean>
		 <!-- SqlMapConfig.xml에서는 JDBC설정부분 주석처리 -->

		 <bean id="sqlMapClient"
		      class="org.springframework.orm.ibatis.SqlMapClientFactoryBean">
		      <property name="dataSource" ref="dataSource"></property>
		      <property name="configLocation"
			    value="classpath:SqlMapConfig.xml"/>       
		 </bean>

		<-- SqlMapClientTemplate-->

		<bean id="SqlMapClientTemplate"
		      class="org.springframework.orm.ibatis.SqlMapClientTemplate">
		      <property name="sqlMapClient" ref="sqlMapClient"></property>
	       </bean>

		<!--DAO계열-->
	       <bean id="boardDAO" class="spring.board.model.BoardDAOImpl">	
		      <property name="sqlMapClientTemplate"
			    ref="SqlMapClientTemplate"/>         	
	
	
		</bean>


		- BoardDAOImpl.java

		public class BoardDAOImpl implements BoardDAO {

			private SqlMapClientTemplate sqlMapClientTemplete;

			public void setSqlMapClientTemplete(SqlMapClientTemplate sqlMapClientTemplete) {
				this.sqlMapClientTemplete = sqlMapClientTemplete;
			}
			//SQLException을 throws하거나 try~catch할 필요 없다
			public List<BoardDTO> list()  {
				List<BoardDTO> list=sqlMapClientTemplete.queryForList("selectAllBoard");
				return list;
			}
			public BoardDTO detail(int idx) {
				return (BoardDTO)sqlMapClientTemplete.queryForObject("selectBoardByIdx", idx);
			}
		}

		※스프링 4.x에서 아이바티스 사용
		http://blog.mybatis.org/2015/11/spring-4-got-you-down-with-no-ibatis.html

		<dependency>
    			<groupId>org.mybatis</groupId>
    			<artifactId>mybatis-2-spring</artifactId>
    			<version>1.0.1</version>
		</dependency>
[iBatis to MyBatis Migration]

	1) MyBatis라이브러리 다운로드

		- www.mybatis.org ->상단 java메뉴 클릭->Download the Persistence Framework 클릭
		  혹은 
		  http://code.google.com/p/mybatis/->downloads->[MyBatis]MyBatis Core Framework 
		  mybatis-3.1.1-bundle.zip 다운로드

		  2017년 1월 17일 현재 
		  http://blog.mybatis.org/p/products.html->Product의 MyBatis 3와 Integration의 Spring다운
		  혹은
		  https://github.com/mybatis/->mybatis-3->•Download Latest->next->mybatis-3.버전 다운
					       spring->13 release->mybatis-spring-1.버전 다운
		  ※SqlSessionFactoryBean 및 SqlSessionTemplate클래스등을 위한 다운로드 
			
		   - 상기 클래스를 설정파일에서 빈으로 생성하여 DAO게열에 주입하여 사용하고자 함
		     이때 iBatis에서 사용하던 SqlMapConfig.xml은 필요 없음.

		

	2) 압축을 푼 후 mybatis-3.1.1.jar 와 mybatis-spring-1.1.1.jar를 WEB-INF/lib에 복사 
	   


	


	3) SqlMapConfig.xml 파일 수정(SqlSessionFactoryBean 및 SqlSessionTemplate 사용시에는 불 필요)

		- mybatis-3.버전.pdf의 2Page에 있는 내용 복사후 수정
			
			1]SqlMapConfig.xml파일명을 ->configuration.xml로 이름 수정 그러나 
			   파일명은 그대로 사용해도 무방함. 
		
			<?xml version="1.0" encoding="UTF-8" ?>
			<!DOCTYPE configuration
			PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
			"http://mybatis.org/dtd/mybatis-3-config.dtd">
			
			<!DOCTYPE mapper
PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
"http://mybatis.org/dtd/mybatis-3-mapper.dtd">

			<configuration>
				
				<typeAliases>
					<typeAlias alias="BoardDTO" type="spring.board.model.BoardDTO"/>
					
				</typeAliases>

				<environments default="development">
					<environment id="development">
						<transactionManager type="JDBC"/>
						<!--
						<dataSource type="POOLED">
						<property name="driver" value="oracle.jdbc.OracleDriver"/>
						<property name="url" value="jdbc:oracle:thin:@127.0.0.1:1521:orcl"/>
						<property name="username" value="green"/>
						<property name="password" value="green"/>
						</dataSource>
						-->
						<!-- JNDI-->
						<dataSource type="JNDI">
							<property name="data_source" value="java:/comp/env/jdbc/myspring"/>
						</dataSource>	
					</environment>
					
				</environments>
				<mappers>
					<mapper resource="spring/board/model/Board.xml"/>
					
				</mappers>
		</configuration>


	4) Board.xml 수정
		
		- mybatis-3.버전.pdf의 4Page에 있는 내용 참고후 수정
		- 루트 엘리먼트가 <mapper>로 바뀜.
		- namespace속성이 필수가 됨.
		  iBatis에서는 생략 가능 했음.
		  namespace는 Mapper를 설정하는 xml을 구분하기 위함.즉 namespace로 묶어서 관리.
		  namespave의 값으로는 해당 xml의 패키지경로를 포함함 xml파일명까지 지정		
		- <typeAlias> 엘리먼트는 SqlMapConfig.xml로 이동후 
		   부모엘리먼트로 <typeAliases>추가
		
			<typeAliases>
				<typeAlias alias="BoardDTO" type="spring.board.model.BoardDTO"/>
			</typeAliases>
		- parameterClass는 ->parameterType으로
		- resultClass는 ->resultType으로
		- 인파라미터는 #파라미터# -> #{파라미터} 로 수정
				     $파라미터$ ->${객체}로 

		<?xml version="1.0" encoding="UTF-8" ?>

		<!DOCTYPE mapper
		PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
		"http://mybatis.org/dtd/mybatis-3-mapper.dtd">

		<mapper namespace="spring.board.model.Board">

		  <!-- Use type aliases to avoid typing the full classname every time. -->
		  



		  <!-- Select with no parameters using the result map for Account class. -->
		  <select id="selectAllBoard" resultType="BoardDTO">
		    select * from boardspring3 order by idx desc
		  </select>

		  <!-- A simpler select example without the result map.  Note the 
		       aliases to match the properties of the target result class. -->

		  <select id="selectBoardByIdx" parameterType="int" resultType="BoardDTO">
		    select
		      *
		    from BOARDSPRING3
		    where idx = #{num}
		  </select>

		  <!-- Insert example, using the Account parameter class -->

		  <insert id="insertBoard" parameterType="BoardDTO">
		    insert into BOARDSPRING3 values(SQ_BOARDSPRING2.nextval,#{writer},#{title},#{content},0,sysdate,#{password})
		  </insert>

		  <!-- Update example, using the Account parameter class -->

		  <update id="updateBoard" parameterType="BoardDTO">
		   update BOARDSPRING3 set writer=#{writer},title=#{title},content=#{content} where idx=#{idx}
		  </update>

		  <!-- Delete example, using an integer as the parameter class -->

		  <delete id="deleteBoard" parameterType="int">
		    delete from BOARDSPRING3 where idx = #{choi}
		  </delete>


		</mapper>



		


	5) BoardManager.java수정

		
		- SqlMapClient 클래스 대신에 SqlSessionFactory클래스를 사용.

		- SqlSession개체를 생성해서 
		다중 레코드는 selectList(), 
		단일 레코드는 selectOne()으로 가져오고
		  입력/수정/삭제는 insert()/update()/delete()메서드로 실행 
		  그리고 입력/수정/삭제는 쿼리 실행후
		  반드시 세션 개체의 commit()호출해야 변경된 내용이 반영됨.
		  또한 close()를 호출해야 한다.
		- 예외처리가 필요 없다.

		package spring.board.model;

		import java.io.Reader;
		import java.io.IOException;
		import java.util.List;
		import java.sql.SQLException;

		import org.apache.ibatis.io.Resources;
		import org.apache.ibatis.session.SqlSession;
		import org.apache.ibatis.session.SqlSessionFactory;
		import org.apache.ibatis.session.SqlSessionFactoryBuilder;


		public class BoardManager {


		  private static SqlSessionFactory sqlMapper;

		
		  /*
		  //설정파일에서 sqlSessionTemplate 빈을 주입 하지 않을때
		  static {
		    try {
		      Reader reader = Resources.getResourceAsReader("configuration.xml");
		     sqlMapper= new SqlSessionFactoryBuilder().build(reader);
		      reader.close(); 
		    } catch (IOException e) {
		      // Fail fast.
		      throw new RuntimeException("Something bad happened while building the SqlMapClient instance." + e, e);
		    }
		  }
		  */
		  //설정파일에서 sqlSessionFactory 와 sqlSessionTemplate 빈 생성후 주입시
		  (SqlSessionTemplate 객체는  내부적으로 AOP를 이용한다 
		  고로 AOP관련 라이브러리가 필요하다)

		  private SqlSessionTemplate sqlSessionTemplate;	
		  public void setSqlSessionTemplate(SqlSessionTemplate sqlSessionTemplate) {
			this.sqlSessionTemplate = sqlSessionTemplate;
		  }
		  public List<SpringBoardDTO> list(){				
	
			List<SpringBoardDTO> list =sqlSessionTemplate.selectList("selectAllBoard");
			return list;
		  }

		  //sqlSessionTemplate 빈 주입 하지 않을때
		  /*
		  public static List<BoardDTO> selectAllBoard() throws SQLException {
			  SqlSession session = sqlMapper.openSession();
		      List<BoardDTO> list=session.selectList("selectAllBoard");			
			  session.close();
			  return list;
		  }


		  public static BoardDTO selectBoardByIdx  (int idx)  {
			BoardDTO dto=null ;	
			SqlSession session = sqlMapper.openSession();
			dto= (BoardDTO) session.selectOne("selectBoardByIdx", idx);
			session.close();
			return dto;
		  }

		  public static void insertBoard(BoardDTO dto) {
			  
			  SqlSession session = sqlMapper.openSession();
			  System.out.println("작성자는"+dto.getWriter());
			  session.insert("insertBoard", dto);
			  session.commit();
		      session.close();
		  }

		  public static void updateBoard (BoardDTO dto) {
			  
			  SqlSession session = sqlMapper.openSession();
			  session.update("updateBoard", dto);
			  session.commit();
		      session.close();
		  }

		  public static void deleteBoard (int idx){
			  
			  SqlSession session = sqlMapper.openSession();
			  session.delete("deleteBoard", idx);
			  
			  session.commit();
		      session.close();
		  }

		  */

		}


		-서블릿명-servlet.xml

		<?xml version="1.0" encoding="UTF-8"?>
		<beans xmlns="http://www.springframework.org/schema/beans"
			xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			xmlns:context="http://www.springframework.org/schema/context"
			xmlns:p="http://www.springframework.org/schema/p"
			xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
				http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd">

			<!-- 스프링에서 제공하는 API를 이용 JNDI(톰캣의 SERVER.XML에 설정된)명으로
				DataSource 얻어 오기
			 -->
			 <context:annotation-config/>
			 
			 <bean id="dataSource" class="org.springframework.jndi.JndiObjectFactoryBean">
				<property name="jndiName" value="jdbc/myspring"/>	 
				<property name="resourceRef" value="true"/>
			 </bean>
			 
			   <!-- ibatis사용시
				<bean id="sqlMapClient"
					      class="org.springframework.orm.ibatis.SqlMapClientFactoryBean">
					      <property name="dataSource" ref="dataSource"></property>
					      <property name="configLocation"
						    value="classpath:SqlMapConfig.xml"/>       
			     </bean>
			     
			     <bean id="SqlMapClientTemplate"
						      class="org.springframework.orm.ibatis.SqlMapClientTemplate">
						      <property name="sqlMapClient" ref="sqlMapClient"></property>
			      </bean>
			     -->
			
			    <!-- MyBatis 사용시-->

			    <bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">
		<!-- 데이타소스:데이타베이스 연결정보 -->
		<property name="dataSource" ref="dataSource" />
		<!-- 환경설정 파일 위치 설정 -->
		<property name="configLocation" 
		value="classpath:mybatis/configuration.xml"/>
	</bean>
		    
		    
			    <bean id="sqlSessionTemplate" class="org.mybatis.spring.SqlSessionTemplate">
					<constructor-arg  ref="sqlSessionFactory" />
			    </bean>
				
			
				<!--  DAO -->	
				<bean id="springBoardDao" class="green.model.SpringBoardDAO" p:dataSource-ref="dataSource">
				<!-- ibatis 사용시-->
				<!--  <property name="sqlMapClientTemplate"
							    ref="SqlMapClientTemplate"/> -->
				<!--mybatis사용시-->			    
				     <property name="sqlSessionTemplate" ref="sqlSessionTemplate"/>   
				</bean>
				
			
			</beans>


	

		※ SqlSessionTemplate사용시 SqlSession객체를 얻는 작업 그리고 insert/delete/update작업인 경우
		   commit해야 하는 작업을 할 필요가 없다.
		   close()도 할 필요 없다.
		   왜냐하면 반복적인 코딩을 하지 않도록 SqlSessionTemplater겍체에 미리 구현해 놓았기 때문에

		   단, SqlSessionTemplate클래스를 사용하려면 AOP관련 라이브러리를 추가해야 한다.
		   (교안에 AOP참조)



[파일 업로드]

	*com.springsource.org.apache.commons.io-1.4.0.jar와 
	com.springsource.org.apache.commons.fileupload-1.2.0.jar파일
	WEB-INF/lib에 복사


	0) 설정파일에 CommonsMultipartResolver클래스 빈 생성 -
	파일 업로드를 위해서 가장 먼저 생성되어야 할 클래스로
	                                                       파일 업로드를 지원해주는 클래스임.

							       
	
		<bean id="multipartResolver"
		class="org.springframework.web.multipart.commons.CommonsMultipartResolver"/>		

		* id는 반드시 multipartResolver로 지정 해야 함. 
		내부적으로 업로드와 관련된 다른 클래스들이 multipartResolver라는 
		id값을 참조해서 사용하고 있음.
		

	1)업로드를 위한 클래스 작성 

		- 클래스앞에 @Controller 지정
		- 메서드 앞에 @RequestMapping("/요청명") 지정 혹은 
		@RequestMapping(value="/요청명",method=RequestMethod.POST)
		  반드시 /를 붙인다 즉 요청이 루트에서 오는지 어디 경로에서 오는지 / 를 붙인다.
		
		  메서드의 인자는 3가지 방식으로 사용자가 전달한 값을 받을 수 있다.


		  방법1) @RequestParam 어노테이션 이용
			:사용자가 전달한 값을 하나씩 받을때
			@RequestParam("파라미터명")어노테이션은  
			request.getParameter("파라미터명")를 호출해 해당 매개변수에
			파라미터로 전달 된 값을 할당하는 역할을 한다.

			예] 메서드(@RequestParam("title") String title,@RequestParam("upFile") MultipartFile upFile)등

		  방법2) 매개변수로 MultipartHttpServletRequest 이용
			
			- 파일 업로드에 특화된 클래스
		        - MultipartHttpServletRequest클래스는 HttpServletRequest와 
			MultipartRequest를 구현한 클래스로
		          일반 값과 파일을 전달 받을때 동시에 사용할 수 잇는 클래스

			예]

			메서드(MultipartHttpServletRequest req) throws Exception{

				String title=req.getParameter("title");
				MultipartFile upFile=req.getFile("upFile");//파일을 받을때는 getFile()
				......

			}


		  방법3) DTO타입의 개체에 받기
			
			- @ModelAttribute어노테이션은 생략 가능. 
			@RequestMapping으로 매핑하게되면 사용자가 
			전달한 값이 커맨트 개체(DTO타입)에 저장되서 전달됨.
			 메서드(HttpServletRequest req,@ModelAttribute UploadDTO dto) throws Exception{
				
				String path = WebUtils.getRealPath(req.getSession().getServeletContext(),"/upload");
				//String path =req.getSession().getServeletContext().getRealPath("/upload");
				String title = dto.getTitle();
				MultipartFile upFile=dto.getUpFile();
				......

		  *UploadDAO클래스
			package spring.fileup;

			import java.io.File;
			import java.io.FileNotFoundException;
			import java.io.FileOutputStream;

			import org.springframework.web.multipart.MultipartFile;

			public class UploadDAO {

				public void saveFile(MultipartFile file,String path,String filename){
					
					try {
						//실제 파일 업로드를 위한 코드
						FileOutputStream fos =
						new FileOutputStream(path+File.separator+filename);
						byte[] data = file.getBytes();
						fos.write(data);
						fos.close();
					} catch (Exception e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					
				}
			}

		  *업로드시 임시 경로에 저장됨(Spring\.metadata\.plugins\org.eclipse.wst.server.core\tmp0\wtpwebapps\FileUploadProj\upload)
		  *MultipartFile클래스의 transferTo()메서드도 파일 저장과 관련된 메서드임.
		  File file=new File(path+File.seperator.upFile.getOriginalFilename());
		  upFile.transferTo(file);

		

	

		- FileUploadController.java

			package spring.fileup;

			import javax.servlet.http.HttpServletRequest;

			import org.springframework.stereotype.Controller;
			import org.springframework.web.bind.annotation.ModelAttribute;
			import org.springframework.web.bind.annotation.RequestMapping;
			import org.springframework.web.bind.annotation.RequestMethod;
			import org.springframework.web.bind.annotation.RequestParam;
			import org.springframework.web.multipart.MultipartFile;
			import org.springframework.web.multipart.MultipartHttpServletRequest;
			import org.springframework.web.servlet.ModelAndView;
			import org.springframework.web.util.WebUtils;
			import java.io.File;

			@Controller
			public class FileUploadController {

				private UploadDAO uploadDao;
				public void setUploadDao(UploadDAO uploadDao) {
					this.uploadDao = uploadDao;
				}
				
				@RequestMapping("/uploadComplete.do")
				//protected ModelAndView fileUpload(HttpServletRequest req ,@RequestParam("name") String name, @RequestParam("upFile") MultipartFile upFile)
				protected ModelAndView fileUpload(MultipartHttpServletRequest req)
				//protected ModelAndView fileUpload(HttpServletRequest req,@ModelAttribute UploadDTO dto)
				throws Exception
				{
					
					
					//1]@RequestParam어노테이션 이용
					/*
					  String path=WebUtils.getRealPath(req.getSession().getServletContext(), "/upload");			
					 
					uploadDao.saveFile(upFile, path, upFile.getOriginalFilename());
					UploadDTO dto = new UploadDTO();
					dto.setName(name);
					dto.setUpFile(upFile);
					*/
					//2] 매개변수로 MultipartHttpServletRequest 이용
					 String path=WebUtils.getRealPath(req.getSession().getServletContext(), "/upload");
					 MultipartFile upFile = req.getFile("upFile");
					 String name = req.getParameter("name");
					 UploadDTO dto = new UploadDTO();
					 dto.setName(name);
					 dto.setUpFile(upFile);
					 
					 upFile.transferTo(new File(path + File.separator + upFile.getOriginalFilename()));
					
					//3]DTO타입에 파라미터값 받기
					//String path=WebUtils.getRealPath(req.getSession().getServletContext(), "/upload");	
					//직접만들 메서드 이용
					/*				
					uploadDao.saveFile(dto.getUpFile(), path, dto.getUpFile().getOriginalFilename());
					*/
					//tansferTo메서드 이용
					/*
					MultipartFile upFile = dto.getUpFile();
					
					upFile.transferTo(new File(path + File.separator + upFile.getOriginalFilename()));
					*/
					return new ModelAndView("/uploadResult.jsp","upload",dto);
				}
			}


		- springFileupload-servlet.xml

			<?xml version="1.0" encoding="UTF-8"?>
			<beans xmlns="http://www.springframework.org/schema/beans"
				xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
				xmlns:p="http://www.springframework.org/schema/p"
				xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
				<bean name="/Test/springTest.do" class="spring.fileup.SpringTestController"/>

				<bean id="multipartResolver"
					class="org.springframework.web.multipart.commons.CommonsMultipartResolver">
					<!-- 최대 업로드 용량 설정
						     단위:바이트 
					     -1:무제한
					-->
					<property name="maxUploadSize" value="2097152"/>
				</bean>
				<bean id="uploadDao" class="spring.fileup.UploadDAO"/>
				
				 <!--파일 업로드 용량 초과시  예외처리-->
				 <bean id="exceptionResolver" class="org.springframework.web.servlet.handler.SimpleMappingExceptionResolver"> 
					<property name="exceptionMappings"> 
						<props> 
							<prop 
							key="org.springframework.web.multipart.MaxUploadSizeExceededException">

							/FileUpload/FileUploadForm.jsp

							</prop> 
						</props> 
					</property> 
				</bean>


				<bean class="spring.fileup.FileUploadController">
					<property name="uploadDao" ref="uploadDao"/>	
				</bean>
			</beans>

		- UloadDAO.java

			package spring.fileup;

			import java.io.File;
			import java.io.FileNotFoundException;
			import java.io.FileOutputStream;

			import org.springframework.web.multipart.MultipartFile;

			public class UploadDAO {

				public void saveFile(MultipartFile file,String path,String filename){
					
					try {
						FileOutputStream fos = new FileOutputStream(path+File.separator+filename);
						byte[] data = file.getBytes();
						fos.write(data);
						fos.close();
					} catch (Exception e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					
				}
			}

		- UploadDTO.java

			package spring.fileup;

			import org.springframework.web.multipart.MultipartFile;

			public class UploadDTO {

				private String name;
				private MultipartFile upFile;
				public String getName() {
					return name;
				}
				public void setName(String name) {
					this.name = name;
				}
				public MultipartFile getUpFile() {
					return upFile;
				}
				public void setUpFile(MultipartFile upFile) {
					this.upFile = upFile;
				}
			}



		- FilUpload.jsp

			<%@ page language="java" contentType="text/html; charset=EUC-KR"
			    pageEncoding="EUC-KR"%>
			<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
			<html>
			<head>
			<meta http-equiv="Content-Type" content="text/html; charset=EUC-KR">
			<title>Insert title here</title>
			</head>
			<body>
				<h2>파일 업로드</h2>
				<form action="uploadComplete.do" method="post" enctype="multipart/form-data">
					이름:<input type="text" name="name"/><br/>
					파일:<input type="file" name="upFile"><br/>
					<input type="submit" value="업로드"/>
				
				</form>
			</body>
			</html>


		- uploadResult.jsp


			<%@ page language="java" contentType="text/html; charset=EUC-KR"
			    pageEncoding="EUC-KR"%>
			<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
			<html>
			<head>
			<meta http-equiv="Content-Type" content="text/html; charset=EUC-KR">
			<title>Insert title here</title>
			</head>
			<body>
				<h2>업로드 결과</h2>
				이름: ${upload.name}<br/>
				업로드 파일명:${upload.upFile.originalFilename}
			</body>
			</html>


[스프링 프레임워크를 이용한 파일 다운로드]

step1]설정파일에 InternalResourceViewResolver빈으로 등록(우선순위 높게)
                       BeanNameViewresolver빈으로 등록(InternalResourceViewResolver보다 우선순위 낮게)
step2]JSP페이지가 아닌 View로 사용할 클래스를 빈으로 등록
        반드시 id값 지정
	(AbstractView클래스를 extends)
 
      

step3]다운로드를 처리할  컨트롤러 클래스에서는
         파일객체를 리퀘스트 영역에 저장만 하고
         저장시 Map이나 Model이나 ModelMap객체로 HttpServletRequest객체로 저장시 전달이 안됨
	 VIEW로 STEP2에서 설정파일에 등록한 빈의 ID값 지정

step4]AbstractView를 상속받은 View클래스에서는
        오버라이딩한 메소드의 첫번째 매개변수 타입인 Map컬렉션에서
	step3에서 리퀘스트 영역에 저장한 파일 객체를
	키값으로 읽어와서 IO작업하면된다.

1. 파일링크를 클릭할때 컨트롤러 클래스에게 파일이름 전달

2. 받은 컨트롤러 클래스에서 그 파일이름으로 file개체생성 (DownloadController)

3. 뷰로 전달

4. 그럼 뷰에서 받은 file 정보를 이용해서 실제 파일을 읽어들인 다음 
   원하는 위치에 쓰는 작업(파일 IO작업) (DownloadView)

 
	※컨트롤러 클래스에서 작업을 한 후, 뷰 페이지로 결과값을 뿌려주는 것인데
	  디폴트  뷰페이지는 JSP 페이지 그러나 다운로드에 사용될 뷰는 JSP 가 아니라  
	  클래스 로 지정 

	그렇기 때문에 아래처럼 일반적으로 사용하던 viewResolver 가 처리하는 것이 아니라


	<bean id="viewResolver" 
	class="org.springframework.web.servlet.view.InternalResourceViewResolver">
			<property name="prefix" value="/"/>
			<property name="suffix" value=".jsp"/>
			<property name="order" value="1"/>
	</bean>  

	download 만을 처리하는 viewResolver 가 따로 존재해야 함.
	여기에는 id값이 없음(주의)
	
	<bean class="org.springframework.web.servlet.view.BeanNameViewResolver">
	     	<property name="order" value="0"/>

	</bean>

	주의할 점은 위 두 코드에 포함된 프로퍼티를 보면 order 라는 프로퍼티가 있는데

	이 프로퍼티는 두개이상 존재하는 viewResolver 를 위해서

	우선순위를 매기는 것이다. 만약 우선순위를 명시 하지 않으면 
	"가장 낮은 우선순위를 갖게 된다."
	우선순위는 "0"이 가장 먼저 실행되고, 이후로 매겨지는 순서에 따라 실행된다.

	다음 viewResolver가 실행되는 기준은 "null" 이 반환되느냐 가 기준이다. 
	즉 null이 반환되면 다음 viewResolver가 실행됨.

	그렇기 때문에 널값이 있을수 없는 InternalResourceViewResolver 가 우선순위가
	높게 되면, 다른 viewResolver 는 사용되지 않게되는 문제가 있다.
	(항상 뷰 이름에 매핑이 되는 뷰 객체를 리턴하기 때문)

	그래서 InternalResourceViewResolver 은 우선순위가 가장 낮아야 한다.


	※BeanNameViewResolver 를 사용법

	BeanNameViewResolver (파일 다운로드 viewResolver)

	"null" 이 반환되지 않는다면, 
	(즉 컨트롤러 클래스에서 리턴되온 뷰페이지 값과 일치하는 빈이 있는 경우)
	
	컨트롤러 클래스에서 리턴되온 뷰페이지 값과 일치하는  빈이 등록되있는 경우는
	그 빈에 해당하는 컨트롤러 클래스가 파일 다운로드를 처리하게 된다.  

	그렇기 때문에 컨트롤러 클래스에서 viewResolver 로 던져줄 뷰페이지 이름과,
	처리할 View 클래스 빈이름이 같아야 한다. 
	
	
	<bean id="download" class="Spring.DownloadView"/>
	- 이 코드가 다운로드를 처리할 뷰 클래스를 등록하는 것이다.
	저기 id="download" 라고 되있는 부분과,컨트롤 클래스에서 리턴된 값이
	같아야 한다.

	그리고 다운로드 url 을 처리할 컨트롤러 클래스도 등록

	<bean id="down" class="Spring.DownloadController"/>



	1] 파일 이름에 링크를 걸어서 컨트롤러 클래스로 넘기는 부분


	<a href="/download.do?fileName=${itemBean.fileName }" >
	다운로드</a>
	download.do 로 파일네임를 넘김


	-다운로드 url 을 처리하는 컨트롤 클래스


	<bean id="down" class="Spring.DownloadController"/>

	@Controller
	public class DownloadController {

		@RequestMapping("/fileUpload/Download.do")   
		public ModelAndView download(HttpServletRequest req,@RequestParam String fileName) {  
		
			String path=req.getSession().getServletContext().getRealPath("/Upload");

			String fullPath = path + File.separator + fileName;   
			File file = new File(fullPath); 
			//View페이지(download)는 View클래스이름과 동일하게
			return new ModelAndView("download", "downloadFile", file);
		}       
	}

	@RequestMapping("/fileUpload/Download.do") 어노테이션으로 지정해준것처럼 
	download.do 가 들어오면 저 메소드가 동작한다. 
	링크에서 준것처럼 파일네임을 받아서

	파일에 조합해서 쓰고 "download" 뷰페이지로 파일을 "downloadFile"이름으로 삽입하고 리턴
	
	 <bean class="org.springframework.web.servlet.view.BeanNameViewResolver">

	저 viewResolver 가 먼저 리턴을 처리하려 할 것이다.

	"download"로 등록된 빈이 있는지 찾아 보는데 우리는 아까 "download"로 뷰클래스를 
	등록시켜 놓았다.  
	<bean id="download" class="Spring.DownloadView"/>

	이제 DownloadView.java 클래스가 뷰페이지로 동작할 것이다.

	뷰페이지에서는 map 에 등록된 파일을 이용해서 encoding 설정과 
	헤더설정을 해준 후 파일을 지정위치에 쓴다.



	//컨트롤러
	- DownloadController.java

		@Controller
		public class DownloadController {

			@RequestMapping("/fileUpload/Download.do")   
			public ModelAndView download(HttpServletRequest req,@RequestParam String fileName) {  
			
				String path=req.getSession().getServletContext().getRealPath("/Upload");

				String fullPath = path + File.separator + fileName;   
				File file = new File(fullPath); 
				//View페이지(download)는 View클래스이름과 동일하게
				return new ModelAndView("download", "downloadFile", file);
			}       
		}

	//View클래스
	-DownloadView.java

			public class DownloadView extends AbstractView {

			@Override
			protected void renderMergedOutputModel(Map model, HttpServletRequest request,
					HttpServletResponse response) throws Exception {
				
				
				File file = (File)model.get("downloadFile");    
				
				//응답 헤더 설정
				response.setContentType("application/octet-stream");//application/unknown
				response.setContentLength((int)file.length()); 
			
				
				boolean ieFlag=request.getHeader("USER-AGENT").indexOf("MSIE") > -1;
				
				
				if(ieFlag)//IE
					response.setHeader("Content-Disposition","attachment;filename="+URLEncoder.encode(file.getName(),"UTF-8"));
				else	//FIREFOX
				response.setHeader("Content-Disposition","attachment;filename="+new String(file.getName().getBytes("UTF-8"),"8859_1"));
				
				BufferedInputStream bis = new BufferedInputStream(new FileInputStream(file));
				BufferedOutputStream bos = new BufferedOutputStream(response.getOutputStream());
				
				int data=0;
				byte[] b = new byte[512];
				while((data=bis.read(b))!=-1){
					
					bos.write(b, 0, data);
					bos.flush();
				}
				bos.close();
				bis.close();
				
		    
			}

		}




	- filedownload-servlet.xml

	<?xml version="1.0" encoding="UTF-8"?>
		<beans xmlns="http://www.springframework.org/schema/beans"
			xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
		<!-- the application context definition for the springapp DispatcherServlet -->


		<bean id="viewResolver" 
			class="org.springframework.web.servlet.view.InternalResourceViewResolver">			
					<property name="order" value="1"/>
		</bean>  
		<bean class="org.springframework.web.servlet.view.BeanNameViewResolver">
				<property name="order" value="0"/>

		</bean>

		<bean id="download" class="spring.DownloadView"/>
		<bean id="downloadController" class="spring.DownloadController"/>
		</beans>



[유효성 검사]

	1.Validator인터페이스를 구현한 Validator클래스 생성
	
	   -support()메소드에서 검증을 지원할 수 있는
	           커맨드 객체인지 판단.
	    support()메소드를 통과해야(true반환)
	          실제 에러 검증을 하는 validate()메소드가 호출됨.
	   
	       커맨드객체명.class.isAssignableFrom(커맨드개체를 받은 매개변수)
	      혹은
	      커맨드객체명.class.equals(커맨드개체를 받은 매개변수)
	  
	  -validate()메소드에서 값 검증이 유효하지 않은 경우
	   Errors타입의 rejectValue("속성명","에러코드값")로
	        에러정보 저장
	
	2.컨틀로러 메소드 작성
	   컨트롤러 메소드의 매개변수에는 커맨드 객체(DTO계열) 및
	 에러정보를 담을 BindingResult타입 추가
	 
	 BindingResult타입의 hasErrors()메소드로 
	 에러검증
	
	3. src밑에 에러내용을 저장한 .properties파일 작성
	   에러코드값.커맨드객체명.속성 = 에러 내용
	   단,커맨드 객체명은 소문자로
	 
	4.설정파일에
	  .properties파일로부터 에러내용을 읽어오기 위한
	  bean등록
	  <bean id="messageSource"
		class="org.springframework.context.support.ResourceBundleMessageSource">
			<property name="basenames">
				<list>
					<value>properties파일의 확장자를 뺀 이름만</value>
				</list>
			</property>	
		</bean>
	  주의:id에는 반드시 messageSource로 지정
	  
	 5. JSP페이지에 에러내용 표시
	    5-1]태그 라이브러 등록
	        uri="http://www.springframework.org/tags/form"
	 
	 	5-2]<접두어:erros path="커맨드객체명.속성명"/>로 에러내용 표시
	 	    커맨드객체명.속성명은 .properties파일에 등록한 키값
	
	-스프링은 객체가 유효한지의 여부를 검사할때 사용되는 Validator인터페이스와 
	 유효성 검사 결과를 저장할 Errors인터페이스를 제공함.
	-org.springframewrok.validation 패키지에 있음.
	(org.springframework.context-3.1.1.RELEASE.jar에 있음)
	- 커맨드 개체(DTO계열)를 사용하는 
	   컨트롤러 클래스들은 커맨드 개체를 생성한뒤 
	  Validator(Validator 인터페이스를 구현한 클래스)에 
	  커맨드 개체를 전달하여 검증을 요청한다.



	1) 스프링 프레임워크에서 제공하는 Validator 인터페이스를 구현한 클래스 작성
	  
	2) 메서드 오버라이딩
		-support()메서드 오버라이딩
			:Validator가 해당 클래스에 대한 값 검증을 지원하는지의 여부를 리턴
			 즉 검증할 개체의 타입정보(클래스)를 파라미터로 전달받아 검사
			 대상 클래스가 
			 커맨드 개체(DTO계열의 클래스)
			 인지 아니면 그 하위 클래스인지 여부를  판단한다. 
			 유효성검사가 가능한 클래스이면 true를 반환
			: support()메서드를 통과해야 validator()메서드가 호출 됨.

			:return DTO계열의클래스.class.isAssignableFrom(arg0);
			//자식 클래스까지 포함

			혹은 
			return DTO계열의클래스.class.equals(arg0)

			
		-validator()메서드 오버라이딩

			:첫번째 매개변수인 arg0는 사용자가 입력한값이 저장되는 
			DTO게열의 클래스(커맨드개체)가 arg0로 전달됨.
			:검증결과 문제가 잇을 경우 두번째 매개변수인 Errors개체에 에러정보 저장
			UploadDTO uploadDto =(UploadDTO)arg0;
			if(!StringUtils.hasLength(uploadDto.getTitle(){ 
			      //StringUtils->스프링에서 제공하는 유틸 클래스(org.springframework.util.StringUtils)
				arg1.rejectValue("속성명", "에러코드값"); 
				//이 에러코드는 뷰에서 에러 메시지를 출력할때 사용함.

			}

		예]

		import org.springframework.util.StringUtils;
		import org.springframework.validation.Errors;
		import org.springframework.validation.Validator;

		public class FormValidaor implements Validator {

			@Override
			public boolean supports(Class<?> arg0) {
				return UploadDTO.class.isAssignableFrom(arg0);
			}

			@Override
			public void validate(Object arg0, Errors arg1) {
				UploadDTO uploadDto = (UploadDTO)arg0;
				
				if(!StringUtils.hasLength(uploadDto.getTitle())){
					arg1.rejectValue("title", "required");
				}
				
				if(!StringUtils.hasLength(uploadDto.getName())){
					arg1.rejectValue("name", "required");
				}
				if(uploadDto.getUpFile().isEmpty() == true){
					arg1.rejectValue("upFile", "required");
				}
				//파일 사이즈 
				if(uploadDto.getUpFile1().getSize() > 1024){ //1k바이트 이상 업로드 못하게
					arg1.rejectValue("upFile", "required");
					
				}
			}
		}

	3) 설정파일에 1)번 클래스 개체 생성
		※@Valid와 @InitBinder 어노테이션을 이용할때만 생성 단, 
		어노테이션을 이용하지 않고  유효성 검증이 필효한 빈에서 
		Validator 인터페이스를 구현한 클래스를 
		  직접 new해서 생성할때는 생략해도 됨.
	

		<bean id="FormValidaor" class="패키지를 포함한 Qualified 경로"/>

		예]
		- springFileupload-servlet.xml

			<?xml version="1.0" encoding="UTF-8"?>
			<beans xmlns="http://www.springframework.org/schema/beans"
				xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
				xmlns:p="http://www.springframework.org/schema/p"
				xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
				<bean name="/Test/springTest.do" class="spring.fileup.SpringTestController"/>
				
				<bean id="FormValidaor" class="spring.fileup.FormValidaor"></bean>
				
				<bean id="multipartResolver"
					class="org.springframework.web.multipart.commons.CommonsMultipartResolver" >
					<property name="maxUploadSize" value="-1"/>  <!--무제한으로 업로드-->
					<property name="defaultEncoding" value="UTF-8"/>
				</bean>
				<bean id="uploadDao" class="spring.fileup.UploadDAO"/>
				<bean class="spring.fileup.FileUploadController">		
					<property name="uploadDao" ref="uploadDao"/>		
				</bean>
				<bean id="messageSource"
					class="org.springframework.context.support.ResourceBundleMessageSource">
					<property name="basenames">
						<list>
							<value>errors</value>
						</list>
					</property>	
				</bean>




	4) 유효성 검증이 필효한 빈 즉 컨트롤러에서
	메서드에 BindingResult result 타입의 매개변수 추가
	   
	
	5) 컨트롤러의  메서드 내에서 Validator를 구현한 클래스 객체 생성후 validate()메서드 호출,
	   호출시 커맨트객체(DTO계열)와 BindingResult타입의
	   파라미터 전달

	6)Erros.hasErrors()메서드로 에러가 존재하는지 확인후 알맞은 처리 수행
	   
		//주의사항
		//매개변수 BindingResult errors를 DTO(커멘드객체)바로 다음에 기술해라

	   method (HttpServletRequest req,@ModelAttribute UploadDTO dto,BindingResult result) throws Exception{
				
		new FormValidaor().validate(dto,result);//validate()메서드는 result에 에러정보를 담아서 넘겨줌
		
		if(result.hasErrors()){//검증결과 에러가 존재하면 즉 validate()메서드에서 한번이상 
		        arg1.rejectValue()메서드가 실행되면 true리턴

			return new ModelAndView("/upload.jsp");//다시 입력폼을 보여준다.
		}

		String path = WebUtils.getRealPath(req.getSession().getServeletContext(),"/upload");
		String title = dto.getTitle();
		MultipartFile upFile=dto.getUpFile();
		......
	 
	
		
		- FileuploadController.java

			package spring.fileup;

			import javax.servlet.http.HttpServletRequest;
			import javax.servlet.http.HttpServletResponse;
			import javax.validation.Valid;

			import org.springframework.stereotype.Controller;
			import org.springframework.validation.BindingResult;
			import org.springframework.web.bind.WebDataBinder;
			import org.springframework.web.bind.annotation.InitBinder;
			import org.springframework.web.bind.annotation.ModelAttribute;
			import org.springframework.web.bind.annotation.RequestMapping;
			import org.springframework.web.bind.annotation.RequestMethod;
			import org.springframework.web.bind.annotation.RequestParam;
			import org.springframework.web.multipart.MultipartFile;
			import org.springframework.web.multipart.MultipartHttpServletRequest;
			import org.springframework.web.servlet.ModelAndView;
			import org.springframework.web.util.WebUtils;
			import java.io.File;

			@Controller
			public class FileUploadController {

				private UploadDAO uploadDao;
				public void setUploadDao(UploadDAO uploadDao) {
					this.uploadDao = uploadDao;
				}
				

				//new UploadValidator().validate(uploadDto,result);를 대체하기 위한 어노테이션
				@InitBinder
				protected void initBinder(WebDataBinder binder){

					binder.setValidator(new UploadValidator());

				}

				@RequestMapping("/uploadComplete.do")
				//protected ModelAndView fileUpload(HttpServletRequest req ,@RequestParam("name") String name, @RequestParam("upFile") MultipartFile upFile)
				//protected ModelAndView fileUpload(MultipartHttpServletRequest req)

				//@InitBinder와 함께 @Valid을 추가하여 직접 클래스내에서 Validator클래스 개체를 생성하지 않고 프레임워크가 해주도록 할 수 있다.
				//@ModellAttribute대신에 @Valid로
				protected ModelAndView fileUpload(HttpServletRequest req,HttpServletResponse res,@Valid UploadDTO uploadDto,BindingResult result)
				throws Exception
				{
					
					res.setContentType("text/html;charset=utf-8");
					//1]@RequestParam으로 구현
					/*
					  String path=WebUtils.getRealPath(req.getSession().getServletContext(), "/upload");			
					 
					uploadDao.saveFile(upFile, path, upFile.getOriginalFilename());
					UploadDTO dto = new UploadDTO();
					dto.setName(name);
					dto.setUpFile(upFile);
					*/
					//2] MultipartHttpServletRequest 로 구현
					 /*String path=WebUtils.getRealPath(req.getSession().getServletContext(), "/upload");
					 MultipartFile upFile = req.getFile("upFile");
					 String name = req.getParameter("name");
					 UploadDTO dto = new UploadDTO();
					 dto.setName(name);
					 dto.setUpFile(upFile);
					 
					 upFile.transferTo(new File(path + File.separator + upFile.getOriginalFilename()));
					*/
					
					
					//@ InitBinder 와 @vALID어노테이션 사용시 생략 
					//new UploadValidator().validate(uploadDto,result);
					
					if(result.hasErrors()){
						System.out.println("입력 오류1");
						return new ModelAndView("/FileUpload.jsp");
					}
					System.out.println("입력 오류2");
					
					//3]@ModelAttribute 로 구현(@ModelAttribute UploadDTO uploadDto)
					String path=WebUtils.getRealPath(req.getSession().getServletContext(), "/upload");	
				
					/*				
					uploadDao.saveFile(dto.getUpFile(), path, dto.getUpFile().getOriginalFilename());
					*/
					
					
					MultipartFile upFile = uploadDto.getUpFile();
					
					upFile.transferTo(new File(path + File.separator + upFile.getOriginalFilename()));
					
					return new ModelAndView("/uploadResult.jsp","upload",uploadDto);
				}
			}


	
	7) 에러 메시지를 .properties파일로 관리(유지보수)
		-classpath밑에 즉 src아래에 생성한다.
		- 에러코드키값.커맨드개체명.속성명 = 에러메시지 작성

		*커맨드개체명(DTO계열)은 자바빈 규칙에 따른 첫글자는 소문자로 즉 UploadDTO인 경우 ->uploadDTO
		예]

		  required.uploadDTO.title=제목을 입력하세요

		- native2ascii로 변환 후 /src 아래에 복사

		-errors.properties

			required.uploadDTO.name = \uc774\ub984\uc744 \uc785\ub825\ud558\uc138\uc694
			required.uploadDTO.upFile = \ud30c\uc77c\uc744 \ucca8\ubd80\ud558\uc138\uc694

		

	8) properties파일 로드하기
	
		- MessageSource로부터 에러코드에 해당하는 에러 메시지를 로딩하기 위한 빈 객체 생성
		
		
		<bean id="messageSource"
		class="org.springframework.context.support.ResourceBundleMessageSource">
			<property name="basenames">
				<list>
					<value>errors</value><!-- 파일이름만-->
				</list>
			</property>	
		</bean>
		

		주의사항:반드시 id 지정 그리고 id값은 messageSource로 내부적으로
		            messageSource가 사용됨

	8) 에러 내용 표시
		
		- 스프링 전용 태그를 사용한 에러내용 표시
		1] 
		   <%@taglib prefix="form" uri="http://www.springframework.org/tags/form"%>

		2]<form:errors path="uploadDTO.title">을 뿌려주고 싶은 위치에->커맨드객체명.속성
			

		<%@ page language="java" contentType="text/html; charset=UTF-8"
		    pageEncoding="UTF-8"%>

		<%@ taglib prefix="form" uri="http://www.springframework.org/tags/form" %>

		<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
		<html>
		<head>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		<title>Insert title here</title>
		</head>
		<body>

			<h2>파일 업로드</h2>
			<form action="uploadComplete.do" method="post" enctype="multipart/form-data">
				이름:<input type="text" name="name" value="${uploadDTO.name}"/><b><form:errors path="uploadDTO.name"/></b><br/>
				파일:<input type="file" name="upFile"><b><form:errors path="uploadDTO.upFile"/></b><br/>
				<input type="submit" value="업로드"/>	
			</form>
		</body>
		</html>


	*@Valid 어노테이션과 @InitBinder어노테이션을 이용해서 컨틀로러 클래스에서 
	  커맨드 개체를 검사하는 코드를 직접적으로 
	 호출하지 않고 스프링 프레임워크가 호출하도록 설정 할 수 있다
	 이때 외부라이브러리 필요(
	 spring-framework-3.0.2.RELEASE-dependencies\javax.validation\com.springsource.javax.validation에 있는
	 com.springsource.javax.validation-1.0.0.GA.jar)

	  1)@ModelAttribute 대신 @Valid어노테이션 사용
	  2)@InitBinder를 지정한 메서드 생성
		@InitBinder
		protected void initBinder(WebDataBinder binder){

			binder.setValidator(new UploadValidator());//UploadValidator()?? Validator??????????? ?????? ?????

		}

	 3) new UploadValidator().validate(uploadDto,result); 부분 주석처리

	*유효성 검사를 하려면  DispatcherServlet보다 먼저 생성되는 스프링의 루트 Context인 
	WebApllicationContext개체가 필요하다
	 그래서 web.xml에 <listener><listener-class>org.springframework.web.context.ContextLoaderListener</listener-class></listener>추가.
	 또한  WEB-INF/밑에 applicationContext.xml을 추가해야 정상적으로 동작
	 *ContextLoaderListener는  WebApllicationContext를 실행시키는 역할을 하는 클래스.


	 	1.Validator인터페이스를 구현한 Validator클래스 생성
	
	   -support()메소드에서 검증을 지원할 수 있는
	           커맨드 객체인지 판단.
	    support()메소드를 통과해야(true반환)
	          실제 에러 검증을 하는 validate()메소드가 호출됨.
	   
	       커맨드객체명.class.isAssignableFrom(커맨드개체를 받은 매개변수)
	      혹은
	      커맨드객체명.class.equals(커맨드개체를 받은 매개변수)
	  
	  -validate()메소드에서 값 검증이 유효하지 않은 경우
	   Errors타입의 rejectValue("속성명","에러코드값")로
	        에러정보 저장
	
	2.컨틀로러 메소드 작성
	   컨트롤러 메소드의 매개변수에는 커맨드 객체(DTO계열) 및
	 에러정보를 담을 BindingResult타입 추가
	 
	 BindingResult타입의 hasErrors()메소드로 
	 에러검증
	
	3. src밑에 에러내용을 저장한 .properties파일 작성
	   에러코드값.커맨드객체명.속성 = 에러 내용
	   단,커맨드 객체명은 소문자로
	 
	4.설정파일에
	  .properties파일로부터 에러내용을 읽어오기 위한
	  bean등록
	  <bean id="messageSource"
		class="org.springframework.context.support.ResourceBundleMessageSource">
			<property name="basenames">
				<list>
					<value>properties파일의 확장자를 뺀 이름만</value>
				</list>
			</property>	
		</bean>
	  주의:id에는 반드시 messageSource로 지정
	  
	 5. JSP페이지에 에러내용 표시
	    5-1]태그 라이브러 등록
	        uri="http://www.springframework.org/tags/form"
	 
	 	5-2]<접두어:erros path="커맨드객체명.속성명"/>로 에러내용 표시
	 	    커맨드객체명.속성명은 .properties파일에 등록한 키값


[예외처리]

-설정파일에  아래 빈 등록
<bean  class="org.springframework.web.servlet.handler.SimpleMappingExceptionResolver"> 
 		<!-- 지정된 예외가 아닌 예외일때 기본적으로 포워딩해줄 view페이지를 세팅할수있다-->
		<property name="defaultErrorView" value="에러발생시 디폴트로 보여줄 경로"/> 
		<property name="exceptionMappings"> 
  			<props> 
   				<prop 
          			key="예외클래스">
				예외 발생시 보여줄 페이지 경로(컨텍스트 루트 경로 제외)
				</prop> 
				<prop 
          			key="예외클래스1">
				예외 발생시 보여줄 페이지 경로1(컨텍스트 루트 경로 제외)
				</prop> 
  			</props> 
  		</property> 
 </bean>


예]

	<bean  class="org.springframework.web.servlet.handler.SimpleMappingExceptionResolver"> 
 		<property name="defaultErrorView" value="/Error/defaultError.jsp"/> 
		<property name="exceptionMappings"> 
  			<props>
				<!--파일 업로드 용량초과 예외 처리-->
   				<prop 
          			key="org.springframework.web.multipart.MaxUploadSizeExceededException">

         			/FileUpload/FileUploadForm.jsp
				</prop>
				<prop key="java.lang.NullPointerException">
					/Error/NullErros.jsp
				</prop>
  			</props> 
  		</property> 
 	</bean>

    -try~catch 불필요
	return "에러페이지" 불필요
	-예외 발생시 DispatcherServlet에게 Model과 View가 전달이 안되고
	 설정파일에 설정한 View로 바로 이동함.
	-개발시에는 주석처리 .개발 완료후 사용 .안그러면
	 어디서 에러가 났는지 알 수 없음

[리소스파일 사용]

	- 외부 리소스 파일인 .properties파일을 사용하여 객체에서 
	필요힌 값들을 리소스 파일로부터 읽어 온다.
	- PropertyPlaceholderConfigurer클래스를 
	  빈으로 등록하여 외부의 리소스파일에 저장된 정보를
	  스프링 설정파일에서 사용한다. 혹은 
	  <context:property-placehoder>엘리먼트를 이용하여 사용한다.

      ※ property-placeholder를 이용해 리소스파일에서
	     키값 설정시  EL식에 빈 공백이 들어가면 설정이 안됨(예외발생) 
	  
	  예]
	  -board.properties(src밑에 config 패키지 생성후 작성)

	  pageSize=10
	  blockPage=10

	  - 방법1]

	    <bean 
	    class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">
		<property name="locations">
			<value>classpath:config/board.properties</value>
		</property>
	    </bean>

	    <!--
	    여러 개의 리소스 파일을 지정시 <list>엘리먼트 이용
	-->
	    <!--
	     <bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">
		<property name="locations">
			<list>
				<value>classpath:config/board.properties</value>
				<value>classpath:config/commons.properties</value>
			</list>
		</property>
	    </bean>




	    <bean id="boardController" class="spring.property.PropertiesController">
		
		<property name="pageSize" value="${pageSize}"/>
		<property name="blockPage" value="${blockPage}"/>
	    </bean>




	방법2]

	- <context:property-placeholder>엘리먼트를 사용하여 외부 리소스 파일 로딩
	- 스프링설정(Spring Bean ConfigurationFile) 파일 생성 시 next후 context선택
	- location속성에 외부 리소스 파일 지정,여러개 지정시에는 콤마로 구분
	- PropertyPlaceholderConfigurer클래스 빈 생성은 하지 않는다.

	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:context="http://www.springframework.org/schema/context"
		xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd">

		<context:property-placeholder location="classpath:config/board.properties,classpath:config/commons.properties"/>
		
		<!--  
		<bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">
			<property name="locations">
				<list>
					<value>classpath:config/board.properties</value>
					<value>classpath:config/commons.properties</value>
				</list>
			</property>
		 </bean>
		 -->
		 <bean class="spring.property.PropertiesController">
			<property name="pageSize" value="${pageSize}"></property>
			<property name="blockPage" value="${blockPage}"></property>
		 </bean>
	</beans>





	[공통파일]


	- PropertiesController.java(컨트롤러 클래스)

		package spring.property;

		import org.springframework.stereotype.Controller;
		import org.springframework.web.bind.annotation.RequestMapping;
		import org.springframework.web.servlet.ModelAndView;

		@Controller
		public class PropertiesController {

			private int pageSize;
			private int blockPage;
			public void setPageSize(int pageSize) {
				this.pageSize = pageSize;
			}
			public void setBlockPage(int blockPage) {
				this.blockPage = blockPage;
			}
			
			@RequestMapping("/properties.do")
			public ModelAndView myMethod(){
				
				ModelAndView mav = new ModelAndView();
				
				mav.addObject("pageSize",pageSize);
				mav.addObject("blockPage",blockPage);
				mav.setViewName("propertiesResult.jsp");
				return mav;
			}
		}
[타일즈3]

	1] 라이브러리 /WEB-INF/lib에 복사	

	스프링 3인 경우]	
	spring-framework-버전.RELEASE-dependencies\org.apache.tiles 아래의 4개 파일 복사

	-com.springsource.org.apache.tiles-2.1.2.osgi.jar
	-com.springsource.org.apache.tiles.core-2.1.2.osgi.jar
	-com.springsource.org.apache.tiles.jsp-2.1.2.jar
	-com.springsource.org.apache.tiles.servlet-2.1.2.jar


	스프링 4인 경우]
	"Apache tiles" 으로 검색후 Download - Binary distribution (Java 6.0 and above)에서
	tiles-3.0.8-bin.zip 다운후 압축풀어서 아래 jar만 WEB-INF/lib에 복사

	-tiles-request-api-1.0.6.jar 
	-tiles-request-servlet-1.0.6.jar  
	-tiles-api-3.0.5.jar  
	-tiles-core-3.0.5.jar 
	-tiles-jsp-3.0.5.jar 
	-tiles-servlet-3.0.5.jar 
	-tiles-template-3.0.5.jar  
	-tiles-request-jsp-1.0.6.jar 
	-slf4j-api-1.7.21.jar 
	-tiles-autotag-core-runtime-1.2.jar

	스프링 4 메이븐 방식인 경우]
	-pom.xml에 아래 의존성태그 추가
	<dependency>
	    <groupId>org.apache.tiles</groupId>
	    <artifactId>tiles-core</artifactId>
	    <version>3.0.5</version>
	</dependency>
	<dependency>
	    <groupId>org.apache.tiles</groupId>
	    <artifactId>tiles-jsp</artifactId>
	    <version>3.0.5</version>
	</dependency>



	-아래 라이브러리는 스프링 3나 4나 동일]-아래 버전 적용할것(최신버전 적용하지 말것)

	spring-framework-버전.RELEASE-dependencies\org.apache.commons\com.springsource.org.apache.commons.digester
	-com.springsource.org.apache.commons.digester-1.8.1.jar

	spring-framework-버전.RELEASE-dependencies\org.apache.commons\com.springsource.org.apache.commons.collections
	-com.springsource.org.apache.commons.collections-3.2.1.jar

	spring-framework-버전.RELEASE-dependencies\org.apache.commons\com.springsource.org.apache.commons.beanutils
	-com.springsource.org.apache.commons.beanutils-1.8.0.jar




	2] 설정파일에 tiles사용을 위한 bean등록

	   스프링 3인 경우(org.springframework.web.servlet-3.x.RELEASE.jar에 포함됨) -org.springframework.web.servlet.view.tiles2.TilesConfigurer

	   스프링 4인 경우(spring-webmvc-4.x.RELEASE.jar에 포함됨) -org.springframework.web.servlet.view.tiles3.TilesConfigurer
	                                                            

	   <bean id="tilesConfigurer" class="org.springframework.web.servlet.view.tiles3.TilesConfigurer">
			<property name="definitions">
				<list>
					<value>/WEB-INF/views/layouts.xml</value>
				</list>
			</property>
		
		</bean>
		
		<bean  class="org.springframework.web.servlet.view.UrlBasedViewResolver">
			<property name="order" value="0"/>  <!-- .jsp도 view로 사용하기 위해 우선순위를 가장먼저--> 
			스프링 3인 경우]
			<property name="viewClass" value="org.springframework.web.servlet.view.tiles2.TilesView"/>
			스프링 4인 경우]
			<property name="viewClass" value="org.springframework.web.servlet.view.tiles3.TilesView"/>
			
	   </bean>

	3] .jsp도 view로 사용하기 위해  InternalResourceViewResolver의 우선순위 는 2]보다 낮게 
	   

		<bean 
			class="org.springframework.web.servlet.view.InternalResourceViewResolver">
				<property name="order" value="1"/>
		</bean>  


	4] tiles설정파일인 layouts.xml작성

	   <?xml version="1.0" encoding="utf-8" ?>
	    스프링 3인 경우]
	     <!DOCTYPE tiles-definitions PUBLIC "-//Apache Software Foundation//DTD Tiles Configuration 2.1//EN" 
         "http://tiles.apache.org/dtds/tiles-config_2_1.dtd">
	    스프링 4인 경우]
	   <!DOCTYPE tiles-definitions PUBLIC
       "-//Apache Software Foundation//DTD Tiles Configuration 3.0//EN"
       "http://tiles.apache.org/dtds/tiles-config_3_0.dtd">


	    <tiles-definitions>
		
		<!-- template에 최상위 페이지명-->
		<definition name="layouts" template="/views/layouts.jsp">
			<put-attribute name="header" value="/views/header.jsp"/>
			<put-attribute name="left" value="/views/left.jsp"/>
			<!-- 내용은 동적으로 변하기때문에 value에 ""지정-->
			<put-attribute name="body" value=""/>
			<put-attribute name="footer" value="/views/footer.jsp"/>
		</definition>
		<definition name="*.tiles" extends="layouts">
			<!-- 와일드 카드 * 이 {1}에 대입됨-->
			 <!-- 즉 컨트롤러에서 index.tiles로 리턴하면 index가 {1}로 치환되서 index.jsp가 보여짐-->
			<!-- *.tiles는 임의로 설정 가능 즉 *.daum로 가능 혹은 *.spring등  단 jsp는 제외-->
			<put-attribute name="body" value="{1}.jsp"/>
			<!--만약 /WEB-INF/밑에 jsp가 있다면
			<put-attribute name="body" value="/WEB-INF/{1}.jsp"/>
			컨틀로러 클래스에서는 return "/WEB-INF/Board/List.tiles"인경우
			/WEB-INF생략
			-->
		</definition>
		<!-- /*/*.tiles 는 불가 즉 *앞에 /를 붙이지 않는다-->
		<definition name="*/*.tiles" extends="layouts">
			<put-attribute name="body" value="{1}/{2}.jsp"/>

		</definition>

		
		<definition name="*/*/*.tiles" extends="layouts">
			<put-attribute name="body" value="{1}/{2}/{3}.jsp"/>

		</definition>

	   </tiles-definitions>

	5] WebContent/views/밑에 최상위 페이지 (layouts.jsp) 및 header.jsp 파일 및 footer.jsp파일 생성


		[layouts.jsp]
		
		<%@ page language="java" contentType="text/html; charset=EUC-KR"
		pageEncoding="EUC-KR"%>
		<%@ taglib uri="http://tiles.apache.org/tags-tiles" prefix="tiles"%>



		<!-- layouts.xml에서 put-attribute 했던 header/content/footer를
		     insertAttribute 태그 삽입-->
		<table width="800" border="1">
		<tr>
			<td height="100" colspan="2"><tiles:insertAttribute name="header"/></td>
		</tr>
		
		<tr>
			<td valign="top">
				<tiles:insertAttribute name="left"/>
			
			</td>
			<td>
		
				<h2>내용 시작</h2>
				<tiles:insertAttribute name="body"/>
				<h2>내용 끝</h2>
			</td>
		</tr>
		<tr>
			<td height="100">
			<tiles:insertAttribute name="footer"/>
			</td>
		</tr>
		</table>


		[header.jsp]

		<%@ page language="java" contentType="text/html; charset=EUC-KR"
		pageEncoding="EUC-KR"%>
		<h2>HEADER</h2>

		[footer.jsp]

		<%@ page language="java" contentType="text/html; charset=EUC-KR"
		pageEncoding="EUC-KR"%>
		<h2>FOOTER</h2>

		[left.jsp]

		<%@ page language="java" contentType="text/html; charset=EUC-KR"
		pageEncoding="EUC-KR"%>
		<h2>LEFT메뉴</h2>



	  

	6] 컨트롤러에서 return 시  layouts.xml에 작성한 패턴으로 리턴  즉 return index.tiles

		예]Controller

		@RequestMapping("/board/BoardSpringList.do")
		//public ModelAndView boardList(HttpServletRequest req){
		public String boardList(HttpServletRequest req){	
			
			
			List<SpringBoardDTO> list=boardDao.list();		
			req.setAttribute("boards",list);		
			return "/BOARD/list.tiles";
		}


		--시작 페이지 링크

		<a href="${pageContext.request.contextPath}/BOARD/BoardSpringList.do">답변형 게시판</a>

		--컨텐츠 구조

		WebContent\BOARD\list.jsp
		

[웹 소켓]	
	-클라이언트(웹 브라우저)와 서버(웹 서버)간에 지속적으로 연결된 TCP 라인을
     통해 실시간으로 데이터를 주고 받을 수 있도록 하는 
	 양방향 통신을 가능하게 하는 HTML5의 새로운 기능
	-데이터 수신을 위해 서버가 클라이언트에게 전송해 주는 푸시(push)방식이다
	 즉 데이타 수신을 위해 클라이언트가 서버에게 요청하는 
	 폴링(polling) 방식이 아니다.
	-플러그 인 없는 일관되고 표준화된 순수 웹 환경에서 실시간 양방향 통신을 위한 
	스펙이 바로 '웹 소켓(Web Socket)' 이다
	-사용 프로토콜 형태는 ws://~~ 형태로 사용	
	-서버부하, 보안(Security)적인 측면과 세션 관리 등의 문제를 가지고 있고 
	 가장 큰 단점으로는 
	 구 브라우저(IE 8.0)에서는 작동하지 않는 문제점이 있다

	현재 주요 브라우저 별 WebSocket 지원여부]
	
		-http://caniuse.com/에서 확인가능

	웹 소켓 구현하기]
		
		-웹 소켓 역시 일반적인 TCP 소켓 통신처럼 
		 서버와 클라이언트간 데이터 교환이 이루어지는 형태이다. 
		-클라이언트에서는 HTML5 웹 소켓이 제공하는 자바스크립트 API를 이용해 서버에 연결하고 데이터를 송/수신하는 코드를 구현해야 하며 
		 서버에서는 웹 소켓 프로토콜에 맞는 전용 장치가 구축되어 있어야 한다


		웹 소켓 클라이언트]
			
			STEP1] 서버연결

				-HTML5가 제공하는 WebSocket 객체를 통해 서버 연결을 수행.
				-일반 통신은 ws, 보안 통신은 wss 프로토콜을 이용한다
				-기본 포트 역시 http,https와 동일한 80,443을 이용한다

				예]var wSocket = new WebSocket("ws://localhost:8080/SpringProj/chat-ws.do");


			STEP2] 데이터 송신

				-WebSocket 객체의 send 함수로 데이터를 서버로 송신할 수 있다
				
				예]wSocket.send("송신 메시지");

			STEP3] 데이터 수신

				-서버에서 푸시(전송)하는 데이터를 받으려면 message 이벤트를 구현하면 된다
				
				예]wSocket.onmessage = function(e){ //매개변수 e를 통해 수신된 데이터를 조회할 수 있다}

			-추가로 아래와 같은 이벤트도 제공된다

			-open이벤트:웹소켓이 연결되었을 때 발생
			-close이벤트: 서버와 연결이 끊겼을 때 발생
			-message이벤트: 서버로부터 메시지가 도착할 때 발생(데이타 수신시 구현)
			-error이벤트: 에러가 났을때 발생하는 이벤트

		웹 소켓 서버]
		
			-웹 소켓은 일반적인 TCP 소켓과는 다른 프로토콜로 설계되었다. 따라서 기존 TCP 서버를 그대로 이용할 수 없고 
			 새로 구현해야 하는데 웹 소켓 서버 사양에 맞도록 구현해야 한다. 
			 
			-Spring 4.0에서부터  웹 소켓 서버를 
			구현 할수 있도록 지원한다.

			

			웹 소켓 서버 구현]


			Step1]웹소켓 모듈 라이브러리 등록
			      비 메이븐 방식-WEB-INF/lib 밑에 spring-websocket-4.버전.RELEASE.jar추가
			      메이븐 방식-pom.xml에  아래 태그 추가
				<dependency>
				    <groupId>org.springframework</groupId>
				    <artifactId>spring-websocket</artifactId>
				    <version>4.2.8.RELEASE</version>
				</dependency>

				※스프링4의 웹소켓 모듈은 서블릿 스펙 3의 웹소켓 기능에 의존함으로
				  서블릿 api 3.0이상인 컨테이너(예]톰켓 8.0)에서만 사용가능하다

			Step2]WebSocketHandler인터페이스 구현

				1)WebSocketHandler인터페이스를 상속받은 클래스로 텍스트 데이타를 주고받을때 사용할 수 있는
				 TextWebSocketHandler클래스 상속받는다
				
				2)메소드 오버라이딩
				스프링의 웹소켓 모듈이 웹 소켓 클라이언트가 연결되거나 
				데이터를 보내거나 연결을 끊을 경우
				아래 메소드들을 호출한다.

				afterConnectionEstablished(WebSocketSession session):웹 소켓 클라이언트와 연결된 경우 호출되는 메소드
				handleTextMessage(WebSocketSession session, TextMessage message):웹 소켓 클라이언트가 텍스트 메시지를 전송할때 호출되는 메소드
				afterConnectionClosed(WebSocketSession session, CloseStatus status):웹 소켓 클라이언트와 연결이 종료된 경우 호출되는 메소드
				

				handleTransportError(WebSocketSession session, Throwable exception):웹 소켓 클라이언트와 연결에 문제 발생시 호출되는 메소드
				WebSocketSession:웹 소켓 클라이언트와의 세션을 관리하는 객체
						 getId()-세션 아이디 반환
						 sendMessage(WebSocketMessage)-웹클라이언트로 텍스트 전송
						 getUri()-엔드포인트 경로 반환
						 isOpen()-소켓이 열려있는지 여부를 리턴
						 close()-소켓을 종료
				TextMessage:웹 소켓 클라이언트가 전송한 텍스트 데이타 정보를 담고 있는 객체
					    getPayload()-클라이언트가 전송한 텍스트 데이타 반환

				CloseStatus:웹 소켓 클라이언트와의 연결 종료에 대한 정보를 담고있는 객체
				            getReason()-클라이언트와의 연결 종료에 대한 이유 반환

			Step3]
			      <websocket:handlers>  이용해 Step2]에서 구현한 WebSocketHandler인터페이스 구현체를 웹소켓 엔드포인트로 등록
			      즉 웹소켓 서버로 설정하거나

			      예]
			       <websocket:handlers>
					<!-- 웹소켓 클라이언트가 연결할때 사용할 엔드포인트와 웹소켓핸들러(웹소켓 서버)객체를  연결
						즉 웹소켓 클라이언트가 /echo로 접속하면 echoHandler가 이를 처리
						/chat으로 접속하면 chatHandler가 이를 처리
					 -->
					<websocket:mapping handler="chatServer" path="/chat-ws.do"/>
				</websocket:handlers>
				<bean id="chatServer" class="controller.websocket.ChatWebSocketHandler"/>
[요청 링크]

JSP에서 링크: 요청명(.do)만 혹은 컨텍스트 루트를 포함한 절대경로  예]${pageContext.request.contextPath}/IBatisBoard/List.do

설정파일(서블릿명-servlet.xml) : /폴더명/요청명  예] /IBatisBoard/List.do


컨트롤러 클래스: 컨텍스트 루트를 제외한 /폴더명/jsp 혹은 jsp페이지만
                      예] /IBatisBoard/List.jsp

[시작문서 설정]

STEP1 ] web.xml에 .do로 요청을 보내도록 시작 문서 설정
	
	   -web.xml

	    <welcome-file-list>
		<welcome-file>index.do</welcome-file>   
	    </welcome-file-list>

STEP2] WebContent 아래에 빈 파일인 index.do파일 생성(WebContent클릭->마우스 우클릭->New ->File->index.do)

STEP3] 서블릿명-servlet.xml에 ParameterizableViewController 컨트롤러를 이용해 jsp페이지(시작페이지)와 매핑 

           아래와 같이 설정

	   <bean name="/index.do" class="org.springframework.web.servlet.mvc.ParameterizableViewController">
		<property name="viewName" value="index.jsp"></property>
	   </bean>
	 
	   value속성에 시작 문서를 설정하면 됨

※ 한글 깨지는거 방지하기 위해 스프링에서 제공하는 필터 이용
  <filter>
	<filter-name>CharacterEncoding</filter-name> <!-- filter-name은 임의로-->
	<filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
	<init-param>
		<!-- param-name과 param-value은 아래처럼-->
		<param-name>encoding</param-name><!--setEncoding()호출-->
		<param-value>UTF-8</param-value>
	</init-param>
</filter>
 <filter-mapping>
  	<filter-name>CharacterEncoding</filter-name> 
  	<url-pattern>/*</url-pattern>
  </filter-mapping>
